# -*- coding: utf-8 -*-
"""Copia de Clase 1 - Introducción a la Programación con Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pusXV8iTqOBWyB1R0tbfgCQ-yQSkTM3T

# ¡Bienvenidos al Curso!
¡Hola! Somos estudiantes voluntarios en la rama estudiantil IEEE del Instituto Tecnológico de Buenos Aires y organizamos este curso de Python gratuito y abierto al público general.

\
<img height="150" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/logo-oficial.png">

\
\
Este curso forma parte de una serie de cursos que ofrecemos, la cual tiene como objetivo principal aprender lo suficiente para automatizar tareas comunes, manipular archivos y hojas de datos de manera eficiente, y representar información gráficamente de manera sencilla. Todas estas tareas pueden ser realizadas usando programación sin necesitar convertirse en un experto del tema.

El contenido de este curso introductorio está orientado hacia aquellos que no tienen experiencia programando en Python. Se verán conceptos y temas fundamentales acerca de la programación y del lenguaje Python, poniendo en práctica lo aprendido mediante desafíos interactivos y ejercicios prácticos.

\
El curso consiste en 3 clases, los temas y conceptos a cubrir son los siguientes:


**Clase 1 :**
*     Introducción a la programación en Python.
*     Variables.
*     Operadores.
*     Control de flujo (if, while, for).
*     Funciones.

**Clase 2 :**
*     Tipos de datos (int, float, string, boolean).
*     Operaciones con tipos de datos.
*     Listas.
*     Operaciones con listas.
*     Manipulación de archivos de texto.

**Clase 3 :**
*     Estructuras de datos (Dictionary, Set, Tuple).
*     Operaciones con estructuras de datos.
*     Introducción a librerías y ejemplos.
*     Casos de aplicación.

\

En nuestro esmero por proveer un curso adaptable y flexible a la disponibilidad de la mayor cantidad de personas, se optó por una modalidad "semi-sincrónica", en la cual los participantes lleven adelante un ritmo similar, pero que dentro de cada semana puedan dedicar su tiempo de la forma que prefieran.

Las clases serán subidas a [nuestra página](https://ieeeitba.org.ar/cursospython) semanalmente y estarán compuestas de videos y textos complementarios como también desafíos prácticos para pensar y resolver. Entre clase y clase tendrán una semana para leer, ver los videos, practicar, y conversar con sus compañeros. El fin de semana entre clase y clase habrá un Livestream donde podrán sacarse las dudas que tengan.

¡No dejen pasar la oportunidad de resolver los desafíos! Son una gran oportunidad para comprender realmente lo que acaban de ver y practicar, algunos son fáciles y otros difíciles así que no se desanimen si tarda en llegar la idea para resolverlos, ya que ese es el punto, desafiarse!

La ejercitación integradora incluye muchos más problemas al final de la clase, en este caso no es crucial terminarlos todos, pero sí les recomendamos hacer los que puedan y de acuerdo al tiempo del que dispongan ya que creemos que la puesta en práctica de los conocimientos es la mejor manera de aprender a programar.

\
**Certificado:** Para obtener un certificado de finalización del curso se deben completar exitosamente los desafíos de entrega obligatoria. Estos desafíos son de corrección automática y sin límites de intentos. Hay 1 desafío a entregar por clase, un total de 3. La corrección se realizará mediante [esta página](https://www.hackerrank.com/2022-1c-curso-introductorio-de-python) utilizando la plataforma HackerRank. Tienen hasta la fecha final del curso para realizar los 3 ejercicios, no se desesperen si alguno les lleva más de una semana.

\
**Comunicación:** Vamos a estar en contacto a través de nuestro [canal de Discord](https://discord.gg/bZ2UXabTN7), allí pueden conversar con otros participantes del curso, y hacer todas las consultas que deseen, por más elementales que puedan ser. Están invitados a participar y ayudar a sus compañeros, además los distintos ayudantes del curso intentaremos ayudarlos con sus consultas, y las que no hayan podido ser respondidas durante la semana se podrán consultar en los Livestreams.

\

**Livestream:** Las transmisiones en vivo serán los días sábados de 19 a 20 hs (UTC−03:00), allí se responderan las dudas y problemáticas más usuales o concurridas, estos quedarán grabados en caso de que no hayan podido verlo en vivo o quieran volver a verlo. El Livestream aparecerá disponible los días y horarios correspondientes en [nuestro canal de Youtube](https://www.youtube.com/channel/UCpWHvOSiPtDIwIw8Tb_9g6A).

\

**Nota 1:** Para poder guardar los ejercicios que resuelvan les recomendamos guardar una copia del documento en su Google Drive. La próxima vez que quieran entrar a la clase y mantener su progreso pueden acceder desde su carpeta de Drive, en lugar de usar el link original.


<img height="300" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/guardar_copia_en_drive.png">

\

**Nota 2:** Si alguno de los videos no les aparece por defecto, deberán ejecutar las celdas de código en la que se encuentra ese video y luego reproducirlo. Para ejecutar una celda, tienen que clickear sobre el botón superior izquierdo del bloque en que se encuentra el código.
Cada video tratará los temas explicados en la clase. Asimismo estos se complementan con la información escrita del curso.

\
¡Esperamos que les sirva!

\
El material es de libre distribución bajo la licencia [Creative Commons](https://creativecommons.org) CC-BY-NC-SA.

A continuación les dejamos un video acerca de cómo será la dinámica del curso y sus clases.
"""

# Link a Youtube: https://www.youtube.com/watch?v=7pjIgZkM_Hc
# Tema: Dinámicas del curso

from IPython.display import YouTubeVideo
YouTubeVideo('7pjIgZkM_Hc', width=800, height=450)

"""# Uso de Google Colab

Uno puede elegir qué plataforma usar a la hora de programar sus proyectos dependiendo de su experiencia, gustos y costumbres. Desde IEEE-ITBA les recomendamos iniciarse utilizando Google Colab, una plataforma gratuita y simple de utilizar que nos brinda Google. 

Posteriormente cuando ya tengan más experiencia, y si así lo desean, pueden descargarse y utilizar otros programas como PyCharm, Visual Studio Code o Sublime. Si bien son un poquito más completos, se requiere descargarlos e instalar el compilador de Python. Brindan muchas más herramientas y posibilidades que esta plataforma.

"""

# Link a Youtube: https://www.youtube.com/watch?v=GO5JY2OWnuI
# Temas: Uso de la plataforma Google Colab

from IPython.display import YouTubeVideo
YouTubeVideo('GO5JY2OWnuI', width=800, height=450)

"""# Clase 1"""

# Link a Youtube: https://www.youtube.com/watch?v=BK08jdq1l6M&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC
# Temas: Introducción a la Programación

from IPython.display import YouTubeVideo
YouTubeVideo('BK08jdq1l6M', width=800, height=450)

"""## Introducción a la programación

La programación es el proceso que se utiliza para diseñar e implementar un programa de computadora, valiéndose de algún lenguaje que permita comunicar una serie de acciones que se requiere que la computadora realice. Podemos pensar que es una caja negra que recibe alguna información, la cual es llamada *input* (entrada), realiza alguna acción, y devuelve información, la cual es llamada *output* (salida).

![Black Box](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/BlackBox.png)

## Lenguajes de programación
Un lenguaje de programación es un [lenguaje formal](https://es.wikipedia.org/wiki/Lenguaje_formal) que proporciona una serie de instrucciones, las cuales permiten a un programador escribir secuencias de órdenes para controlar el comportamiento físico y lógico de una computadora, con el objetivo de que produzca diversas acciones deseadas por el programador (¡y los usuarios!).

Algunos de los lenguajes mas populares en los últimos tiempos (lejos de ser los únicos) son Python, Java, C++, JavaScript, PHP, etc.

<img src="https://i.imgur.com/12T9u0f.jpg" height="300" alt = "Collage de lenguajes de programación populares" title="Hay varios otros lenguajes, como Go, Go!, Gosu etc. ">

### ¿Por qué Python?
Elegimos Python porque es uno de los lenguajes de programación con reglas más simples e intuitivas que existen; esto explica la creciente popularidad que ha tenido en los ultimos tiempos.

A pesar de su simpleza, es muy utilizado tanto en la industria para servidores y servicios web, así como también en el área académica para redes neuronales, deep learning, simulación, etc.

La comunidad de Python es una de las más grandes. Por lo tanto cualquier duda que tengan, a partir de ahora, Google es su amigo: pueden buscar la duda que tengan y seguramente alguien ya haya tenido ese problema. Una de los sitios web más conocidos para este fin es [StackOverflow](https://stackoverflow.com/).

## Input, Output y Variables
"""

# Link a Youtube: https://www.youtube.com/watch?v=su9lzFaYhbM&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=3&ab_channel=IEEEITBA
# Temas: Input, Output y Variables.

from IPython.display import YouTubeVideo
YouTubeVideo('su9lzFaYhbM', width=800, height=450)

"""### Output

El output de un programa es la manera de transmitir información hacia el entorno externo. Por ejemplo, puede escribir en la consola de la computadora, puede generar una imagen, reproducir un sonido, etc. En Google Colaboratory veremos el output del programa debajo de la celda donde fue ejecutado.

Para poder mostrar texto, podemos utilizar la instrucción **print( )** poniendo lo que deseemos mostrar entre los paréntesis. Más adelante veremos cómo se pueden generar imágenes, archivos y demás.

**Tip**: En la esquina superior izquierda del cuadro de texto con el código hay un botón para ejecutar el programa
"""

print(123)
print("Hola, cómo estas?")
print('Buen día')

"""Noten en el ejemplo que para escribir texto se debe indicar con comillas simples o dobles y para escribir números no se usan comillas.

Otra cosa importante para notar es que cada instrucción en Python se escribe en un renglón distinto, y se ejecutarán una por una de arriba para abajo.

Cada instrucción **print( )** muestra el contenido indicado en un renglón nuevo, pero también admite mostrar mensajes en un mismo renglón si se indican diferentes parámetros separados con comas:
"""

print(1, 2, 3)
print("Curso", "de", "Python")
print('Uno:', 1, ' Dos:', 2, ' Tres:', 3)

"""### Variables

Para poder realizar tareas es necesario guardar en la memoria de la computadora los datos que necesita mi aplicación para funcionar. Por ejemplo, en este momento tu navegador web sabe cuántas pestañas hay abiertas y qué página se abrió en cada una, sabe en qué posición de la página estás y qué usuario utilizaste para entrar a Google Colab. Todos estos datos están almacenados en la memoria de la computadora y el navegador lee estos datos y los modifica cada vez que lo requiere.
\
En programación, se le asigna un nombre o apodo a cada pequeño segmento de la memoria que almacena un dato o un valor. De esta forma en el programa cada vez que se usa este nombre se esta refiriendo al valor del dato almacenado en la memoria. Este es el concepto de "variable".
\
En python esto se logra de la siguiente manera:
"""

x = 5
print(x)

"""Este ejemplo utilizará un bloque de la memoria para almacenar el número `5`, luego le asigna a este bloque el nombre `x` y por lo tanto a partir de entonces cada vez que se utiliza la palabra `x` en realidad nos referimos al valor almacenado dentro del bloque de memoria, al cual apodamos `x`.

**¿Cómo se interpreta una expresión de asignación?**

Es muy importante entender cómo leer una expresión de asignación.
Cuando recorras y analices tu código, es preferible que entiendas el significado de la operación:

*nombre* = *expresión*

Como:
* Se **asigna** el valor de *expresión* a *nombre*.

Y no como:
* ~~*variable* es *igual* a *expresión*~~.

**Ejemplos**

En estas variables podemos guardar lo que sea necesario para ejecutar el programa, por ejemplo si necesitamos guardar texto se indica con: "(texto)" o '(texto)'.
"""

x = 'Hola'
y = "Adios"
z = 123
print(x)
print(y)
print(z)

"""Noten que la instrucción **print( )** permite mostrar el contenido de una variable. Cuando ponemos **print(x)** no imprime la letra *x* sino que imprime el contenido de **x**. Es por esto que para eliminar la confusión se usan comillas cuando queremos mostrar texto y no el contenido de una variable.

Es importante tener en cuenta que no es necesario aclarar de antemano si las variables son textos (Strings) o números, el lenguaje lo puede identificar automáticamente

**Reglas para el nombre de una variable:**

- Debe empezar con una letra (a-z, A-Z) o un guión bajo (_).
- Los otros caracteres pueden ser letras, numeros o guión bajo.
- Distingue mayúsculas de minúsculas.
- Existen palabras reservadas que no se pueden usar como nombre de variable porque Python las usa para otras cosas. Por ejemplo el nombre de una variable no puede ser print.

**Prolijidad y buenas prácticas**

Cuando se escribe código, no solamente se está utilizando un lenguaje de programación para poder aprovechar los recursos de una computadora. Al igual que cualquier otra actividad humana, la tarea de programar se vuelve más interesante cuando se realiza junto a otras personas.

De hecho, para realizar ciertos trabajos de mucha complejidad, no es posible que un único individuo se encargue de escribir todo el código. Por eso, es importante ser prolijos y utilizar buenas prácticas de programación, para que otras personas puedan entender nuestro código (incluído nuestro yo del futuro) y de esa forma corregirlo o agregarle funcionalidad.

Unos tips  que ya pueden a empezar a usar son:
* Separar el nombre de la variable, el operador de asignación y la expresión a evaluar con espacios.

Es decir, en lugar de escribir:
```python
x="Hola mundo!"
```
Es mejor escribir:
```python
x = "Hola mundo!"
```

* Elegir nombres de variables descriptivos, aunque nos de pereza escribirlos.

```python
radio = 5
pi = 3.14
perimetro = 2 * pi * radio
areaEsfera = 4 * pi * radio**2
volumenEsfera = 4 / 3 * pi * radio**3
```

#### **Mini-desafío:** Output y variables

Diseñar un programa en el cual se definan exactamente 2 variables.
- La primera se debe llamar `nombre` y debe contener tu nombre (entre comillas).
- La segunda se debe llamar `edad` y debe contener tu edad (como un número simple, sin comillas).

Por último el programa debe mostrar en pantalla la siguiente frase en una sóla línea: 
> (nombre) tiene (edad) años

Por ejemplo:
> Mati tiene 5 años

**Tip:** La instrucción print() admite mostrar mensajes en un mismo renglón si se indican diferentes parámetros separados con comas.
"""

nombre = "Mati"
edad = 5

print(nombre, 'tiene', edad, 'años')

"""### Input
El input de un programa es la manera de recibir información del entorno externo al programa. Esto puede ser un usuario, un archivo, otro programa, un sensor, etc. 

Para ingresar una variable podemos usar **input( "Texto a mostrar:" )**. Corran este código ustedes para que les de una pequeña casilla donde escribir, y luego el programa escribirá lo que ustedes ingresaron. 
"""

# Esto es un comentario!
# Los comentarios no son ejecutados por Python
# De esta forma el programador puede hacer una nota para humanos

nombre = input("Ingrese su nombre: ")
edad = int( input("Ingrese su edad: ") )

print("nombre:", nombre)
print("edad:", edad)

"""Un detalle a tener en cuenta es que la información ingresada por el usuario usando **input( )** será interpretada como texto, no como un número. Por eso cuando queremos ingresar un número usaremos **int( )** para convertir ese texto al número correspondiente. En la próxima clase quedará claro por qué debemos hacer esto y qué es el tipo de una variable.

## Operaciones básicas con variables

### Operaciones de modificación
"""

# Link a Youtube: https://www.youtube.com/watch?v=6Bb1i1lBaYM&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=4&ab_channel=IEEEITBA
# Tema: Operaciones de modificación.

from IPython.display import YouTubeVideo
YouTubeVideo('6Bb1i1lBaYM', width=800, height=450)

"""No sería muy útil un programa si lo único que podemos hacer es guardar en una variable y mostrarla, por lo que existen algunas operaciones básicas que nos permiten modificar el contenido:

- Sumar dos variables ( $a+b$ ):

  `a + b`

- Restar dos variables ( $a-b$ ):

  `a − b`

- Multiplicar dos variables ( $a\cdot b$ ):

  `a * b`

- Dividir una variable por la otra ( $a\div b$ ):

  `a / b` 

- Una variable elevada a la otra ( $a^b$ ): 

  `a ** b`

- Asignarle un valor a una variable ( $a\leftarrow b$ ):

  `a = b`
  

¿Cual será la salida del siguiente programa?
"""

x = 3
y = -2
y = x*y
x = x**2
print("y =", y)
print("x =", x)

"""Python nos permite ahorrar código combinando el operando **=** con alguno de los anteriormente vistos:

*   Suma a la varaible ( $a \leftarrow a+ b$ ):

  `a += b`

*   Resta a la variable ( $a \leftarrow a- b$ ):

  `a -= b`

*   Multiplica a la variable ( $a \leftarrow a\cdot b$ ):

  `a *= b`

*   Divide a la variable ( $a \leftarrow a\div b$ ):

  `a /= b`

¿Cual será la salida del siguiente codigo?
"""

x = 17
x += 3
x /= 10
print("x =",x)

"""**Prolijidad y buenas prácticas**
Al igual que al asignar, a veces introducir espacios al escribir expresiones vuelve más legible el código.

¿Cúal de las siguientes asignaciones te parece más prolija y entendible?

```python
a = 5+4/4**5*3-7*x+b
```
```python
a = 5 + 7 / 4**5 * 3 - 7 * x + b
```

#### **Mini-desafío:** Operadores

1. Diseñar un programa en el cual el usuario ingrese tres números, uno a la vez, y se muestre a la salida el promedio de los tres números.
2. Diseñar un programa en el cual el usuario ingrese tres números, uno a la vez, y se muestre a la salida la [media geométrica](https://es.wikipedia.org/wiki/Media_geom%C3%A9trica) de los tres números.

  **Tip:** Usando el operador de potencia se puede calcular una raíz cúbica ya que: $\sqrt[3]{x}=x^{1/3}$
"""

n1 = int(input("Ingrese el primer numero: "))
n2 = int(input("Ingrese el segundo numero: "))
n3 = int(input("Ingrese el tercer numero: "))

p = (n1+n2+n3)/3

print("El promedio de los tres numeros anteriores es ", p)

n1 = int(input("Ingrese el primer numero: "))
n2 = int(input("Ingrese el segundo numero: "))
n3 = int(input("Ingrese el tercer numero: "))

mg = (n1*n2*n3)**(1/3)

print("La media geometrica de los tres numeros anteriores es ", mg)

"""### Operador módulo

"""

# Link a Youtube: https://youtu.be/4GlRXyCXb4c
# Tema: Operador módulo.

from IPython.display import YouTubeVideo
YouTubeVideo('4GlRXyCXb4c', width=800, height=450)

"""El operador módulo se utiliza con el símbolo **%**, y permite calcular el resto de un numero en la división por otro. Por ejemplo:

*   $5$ % $3$ $= 2$
*   $17$ % $10$ $= 7$
*   $9$ % $6$ $= 3$
*   $15$ % $5$ $= 0$

Podríamos por ejemplo preguntar si el resto de un numero **x** en la division por **y** es igual a 0 y así saber si **x** es multiplo de **y**:
"""

x = 27
y = 9
print("Resultado:", x % y )

"""#### **Mini-desafío:** Módulo
Un grupo de alumnos están cansados de estudiar. Se les ocurre que puede ser una buena idea tomarse unos días para tomar sol y hacer ejercicio, pero como no son para nada moderados, deciden organizar una ultramaratón de 4096 kilómetros. La carrera empezará a medianoche, y se cronometra la cantidad de horas que tarda cada corredor en finalizar. Es probable que a los corredores les tome varios días lograr alcanzar la meta.

![Marathon](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/marathon.png)

Realizar un programa al cual se ingresa la cantidad de horas que tardó un corredor en alcanzar la meta, y que muestra en pantalla la hora del día a la que llega.

**Ejemplos:**
- *Input* ← `5`

  *Output* → `5` (Como tarda 5 horas, llega a las 5:00)

- *Input* ← `20`

  *Output* → `20` (Como tarda 20 horas, llega a las 20hs)

- *Input* ← `25`

  *Output* → `1` (Como tarda 25 horas, llega a la 1:00)

- *Input* ← `45`

  *Output* → `21` (Como tarda 45 horas, llega a las 21:00)
"""

hora = int( input("Ingrese las horas que tardo en alcanzar la meta: ") )

print( hora%24 )

"""### Operaciones de comparación

"""

# Link a Youtube: https://www.youtube.com/watch?v=9HoKXY8uKVA&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=6&ab_channel=IEEEITBA
# Tema: Operaciones de comparación.

from IPython.display import YouTubeVideo
YouTubeVideo('9HoKXY8uKVA', width=800, height=450)

"""Existen operaciones para comparar propiedades de las variables, que serán especialmente importantes para el próximo tema de la clase. Las principales comparaciones posibles son:

*   Menor que ( $a < b$ ):

 `a < b`

*   Mayor que ( $a > b$ ):

 `a > b`

*   Menor o igual que ( $a \leq b$ ):

 `a <= b`

*   Mayor o igual que ( $a \geq b$ ):

 `a >= b`

*   Es igual ( $a = b$ ):

 `a == b` (Ojo: se utilizan 2 símbolos `=` para diferenciarse del operador asignación)

*   Es distinto ( $a \neq b$ ):

 `a != b`


Al comprarar dos números se obtiene True o False (Verdadero o Falso) según si se cumple la condición:
"""

x = 4
print("Es x mayor o igual a 4?", x >= 4)
print("Es x menor a 3?", x < 3)

"""También podemos combinar diversas condiciones:

*  Si se cumplen las dos condiciones ( $a \land b$ ):

  `a and b`

*  Si se cumple alguna de las condiciones ( $ a \lor b$ ):

  `a or b`

*  Si no se cumple esa condición ( $ \overline{a} $ ):

  `not a`


Veamos un ejemplo:
"""

x = int(input("Ingrese un numero:"))
y = x > 5 and x < 7
z = x > 5 or x < 7
k = not x > 5
print("x > 5 y x < 7?", y)
print("x > 5 ó x < 7?", z)
print("Es x NO mayor a 5?", k)

"""Estas condiciones pueden agruparse con ( condicion1 ) **and/or** ( condicion2 ), esto permite chequar condiciones complejas:"""

x = int(input("Ingrese el primer número:"))
y = int(input("Ingrese el segundo número:"))
z = ( x > 15 or x < -15) and ( y > 15 or y < -15 )
print("El valor absoluto de ambos numeros es mayor a 15?", z)

"""**Prolijidad y buenas prácticas**

¿Ven el uso de espacios y paréntesis en las expresiones?

Al incrementar la complejidad del código que se escribe no resulta ni sencillo ni práctico crear reglas rígidas que establezcan la forma más prolija de escribir código. Por eso, se apela al sentido común cuando se programa.

## Control de Flujo
Los programas siguen un "flujo" definido por el programador. Hasta ahora el flujo del programa siempre fue uno sólo, se ejecuta una instrucción, luego la siguiente, luego la siguiente a esta, etc. Sin embargo es posible realizar tareas diferentes dependiendo de ciertas condiciones, repetir segmentos de código, y modificar el flujo del programa de forma que no sea simplemente una secuencia lineal de instrucciones. Esto permite realizar tareas mucho más complejas, en la cuál el programa tome decisiones respecto a lo que debe hacer en función de la situación.

Notar que todas estas estructuras terminan con un "**:**" , y la siguiente línea tiene un tab de indentación (como una sangría).

###   Estructura if
"""

# Link a Youtube: https://www.youtube.com/watch?v=IGiU5pAW1h0&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=7
# Tema: Bloque if.

from IPython.display import YouTubeVideo
YouTubeVideo('IGiU5pAW1h0', width=800, height=450)

"""El **if** es la estructura básica que le permite al programador analizar si se cumple una condición, y realizar distintas acciones según si eso sucede o no. Las distintas formas de implementar la estructura son las siguientes:

```python
if (condicion):
    #Lo que se hace si se cumple la condición
```
```python
if (condicion):
    #Lo que se hace si se cumple la condición
else:
    #Lo que se hace si no se cumple la condición
```
```python
if (condicion1):
    #Lo que se hace si se cumple la condición1
elif (condicion2):
    #Lo que se hace si no se cumple la condicion1, pero sí la condicion2
elif (condicion3):
    #Lo que se hace si no se cumple la condicion1 ni la condición2, pero sí la condición3
else:
    #Lo que se hace si no se cumple ninguna condición
``` 
    
Se debe prestar especial atención a la indentación/tabulación. Siempre que se define un **if** se crea un bloque de código (un conjunto de instrucciones) que son las que se ejecutan cuando se cumple la condición dada. Este bloque de código debe tener una "sangría", de esta forma Python comprende donde empieza y donde termina este bloque. Si se utiliza la "sangría" incorrectamente Python indicará que hay un error en el código y no se podrá ejecutar.

Siempre se comienza con **if**, después puede haber cualquier cantidad de **elif** (o ninguno) y luego se puede terminar con **else** (o no). Luego del **else** no puede haber más **elif**.
 
 ¿Cual será la salida del siguiente programa?
"""

x = 5
y = 6
if x == y:
    print(x)
elif y < 5 or y > 7:
    print(x + y)
else:
    print(y)

y = int(input("Ingrese el valor de y"))
if y == 13:
    print("Adivinamos el valor de y!")      

x = int(input("Ingrese el valor de x"))    
if x == 93:
    print("Adivinamos el valor de x!")
else:
    print("No adivinamos el valor de x  :(")
    
if x > y:
    print("x es mayor que y")
elif x < y:
    print("y es mayor que x")
elif x == y:
    print("x e y son iguales")
else:
    print("que anda pasando?")

"""**Tips**

Para indentar y desindentar, se usa la tecla *tabulador* junto con la tecla *shift/mayus*. Recomendamos que busquen en su teclado esta tecla y si no la conocen, pueder pedirle ayuda a Google.

Si se quiere añadir o quitar tabulaciones a varias líneas, pueden seleccionarlas primero.

#### **Mini-desafío:** if
1. Realizar un programa que revise si una nota está aprobada (es decir si es mayor o igual a 4) utilizando un **if/else**. La nota será ingresada por el usuario usando **input()**.
2. Realizar un programa que convierta una nota porcentual del 0 al 100 a una letra entre A y F de acuerdo a la siguiente conversión:

 - A: 90–100

 - B: 80–89

 - C: 70–79

 - D: 60–69

 - F: 0–59
"""

nota = int(input("Ingrese nota: "))

if nota>=4:
    print('Aprobado')
    
else:
    print('Desaprobado')

nota = int(input("Ingrese nota:"))

if nota > 100 or nota < 0:
    print('Nota fuera de rango 0-100')

elif nota >= 90:
    print('Nota: A')

elif nota >= 80:
    print('Nota: B')

elif nota >= 70:
    print('Nota: C')

elif nota >= 60:
    print('Nota: D')

else:
    print('Nota: F')

"""###  Estructura while

"""

# Link a Youtube: https://www.youtube.com/watch?v=GBWvoYlbTRs&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=8
# Tema: Bloque while.

from IPython.display import YouTubeVideo
YouTubeVideo('GBWvoYlbTRs', width=800, height=450)

"""La estructura **while** permite implementar *ciclos* en nuestro programa (también llamados *loops* o *bucles*). Es decir, repetir una porción del código una y otra vez en tanto se verifique cierta condición. La estructura básica es la siguiente:



```python
while (condicion):
    #Lo que se hace mientras que se cumpla la condicion
    #Debe incluirse una operación que modifique la condición
```

En el siguiente bloque de código pueden ver a esta estructura en acción:
"""

x = 1
while x < 10:
    print(x)
    x += 1

print('Termina el while')

print("Continuo con el resto del programa")

"""Es importante tener en cuenta que la condición se evalúa sólo al principio del ciclo y no se volverá a evaluar hasta no terminar de ejecutar todas las instrucciones contenidas en el bloque **while**.

Al usar una variable auxiliar para contar la cantidad de repeticiones del while, es recomendable no modificar su valor dentro del bloque excepto para incrementar/decrementar su valor acordemente. Esto es porque se corre el riesgo de que la condición siempre sea *True* y el **while** se ejecute infinitamente, además es dificil darse cuenta de que la cantidad de ciclos será de hecho la que queremos.

¿Qué realiza este programa?
"""

nota = int( input('Ingrese un número del 1 al 10: ') )

while nota < 1 or nota > 10:
  print('Fuera de rango!')
  nota = int( input('Ingrese un número del 1 al 10: ') )

print("La nota es mayor a 4?", nota >= 4 )

"""**Prolijidad y buenas prácticas**

Recordar: siempre que se excriba un bucle while, se debe modificar en algún punto la condición que controla su ejecución. Bajo ninguna circunstancia puede entregarse un programa con bucles cuyo fin no es seguro. ¿O acaso a alguien le gusta que su computadora se quede colgada?

#### **Mini-desafío:** while

1. Implementar un programa que reciba 2 números (A y B), y luego imprima en pantalla la secuencia de números enteros desde A hasta B. En el caso de que B sea menor que A, se debe repetir el pedido de B hasta que sea válido ( B $\geq$ A ).

2. Implementar un programa que muestre la siguiente secuencia:

  1, 2, 3, 4, 5, 4, 3, 2, 1, 0

  **Para un desafío mayor:** Utilizar 1 solo *while*, 1 solo *if* y 1 solo *else*. Es recomendable que la variable usada para contar los pasos se mantenga contando siempre de la misma forma.
"""

LosNumerosSonCorrectos = False

while (LosNumerosSonCorrectos == False):
  
      A = int(input("Ingrese valor A: "))
      B = int(input("Ingrese valor B: "))

      if (B >= A):
        LosNumerosSonCorrectos = True
        
      else: 
          print("Los numeros no son correctos, B tiene que ser mayor que A.")
          print("Ingrese los valores nuvamente.")
        

while (A <= B):
  print(A)
  A += 1

x = 1

while x <= 10:
    if x < 6:
        print(x)
    else:
        print(10-x)
    x+=1

"""### Estructura for

"""

# Link a Youtube: https://www.youtube.com/watch?v=4yqiNkuTG_4&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=9
# Tema: Bloque for.

from IPython.display import YouTubeVideo
YouTubeVideo('4yqiNkuTG_4', width=800, height=450)

"""La estructura del **for** permite realizar una serie de acciones con una variable, que cambia su valor en cada repetición (también llamada *iteración*).

```python
for (variable) in (conjunto de valores):
    #Lo que quieras hacer con tu variable
```

Veámoslo en un ejemplo de código:
"""

for x in range(0,15,5):
    print(x)

"""La instrucción `range(a,b,d)` genera los valores desde *a* hasta *b* (sin incluir) con incrementos de *d*, por ejemplo el siguiente codigo generara los numeros pares entre 0 y 10:"""

for x in range(0,10,2):
    print(x)

"""Noten que el límite superior del rango nunca es incluído."""

init = int(input("Ingrese el inicio:"))
fin = int(input("Ingrese el fin:"))
step = int(input("Ingrese el salto:"))

for x in range(init, fin, step):
    print("x =", x)

"""Al utilizar la instrucción **range( )** no es necesario proporcionar siempre los 3 parámetros. Observen qué sucede cuando se proporcionan solamente 1 o 2 parámetros:"""

print("range(5):")
for x in range(5):
    print(x)

print("range(10, 15):")
for x in range(10, 15):
    print(x)

"""#### **Mini-desafío:** for
Realizar un programa para controlar el sistema de impresión de etiquetas con códigos de barras en un supermercado. Primero se debe ingresar la cantidad de productos diferentes que necesitan etiquetas. Luego, para cada producto, se ingresa el código a imprimir y la cantidad de veces que hay que imprimirlo. Posteriormente el programa imprimirá dicho código.

![Barcode Printer](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/barcode_printer.jpg)

Imprimir en pantalla los códigos solicitados la cantidad requerida de veces.

**Ejemplo:**

Las líneas indicadas con ```>>``` corresponden a *Inputs*. Las líneas sin indicaciones corresponden a *Outputs*:
```
>> 3 (cantidad total de productos)
>> 000000123 (primer código)
>> 1 (veces que hay que imprimir dicho código)
000000123
>> 123000789 (segundo código)
>> 3
123000789
123000789
123000789
>> 000031416 (tercer código)
>> 2
000031416
000031416
```

**Observación:**

Los códigos se imprimen a medida que se ingresan, no es necesario guardar todos los códigos y sus cantidades e imprimirlos al final de la ejecución. 
"""

variedad = int(input("Ingrese la variedad de productos:"))

for x in range(variedad):
    barras = input("Ingrese el codigo de barras correspondiente:")
    cantidad = int(input("Ingrese la cantidad del producto:"))

    for y in range (cantidad):
      print(barras)

"""## Funciones"""

# Link a Youtube: https://www.youtube.com/watch?v=q63aQmf_73A&list=PL0YqVCFDPJTnJYWRxmGJsj_xJA-FfdySC&index=10
# Tema: Funciones.

from IPython.display import YouTubeVideo
YouTubeVideo('q63aQmf_73A', width=800, height=450)

"""Podemos pensar que una función es como tomar un conjunto de instrucciones y empaquetarlas bajo el mismo nombre, es como un pequeño programa dentro del programa, una manera de crear nuestras propias instrucciones. Las funciones son bloques que nos permiten acortar el código, no repitiendo estructuras que necesitamos utilizar mucho. Al igual que los programas las funciones tienen un *input* y un *output*: el input son las variables de entrada y su output es el valor o valores que devuelven.

Por ejemplo, supongamos que frecuentemente necesito calcular las ganancias totales generadas por cierto producto que se encuentra a la venta en mi negocio. Cada vez que quiera realizar este cálculo tendré que obtener el costo de venta, restarle el costo de fabricación y multiplicarlo por la cantidad de ventas. Usando una función puedo crear mi propia instrucción a la que se le ingrese el código de producto y devuelva el resultado. Así puedo escribir el nombre de la función cada vez que quiera hacer este cálculo sin tener que escribir nuevamente el procedimiento completo.

En Python las funciones se implementan de la siguiente forma:

```python
def miFuncion( a , b , c , ...):
    
    #Hago lo que necesite con las variables a, b, c, ...
    
    return x , y , z , ...
```
En este ejemplo, el nombre de la función es `miFuncion`, los parámetros de entrada son las variables `a , b , c , ...` que se indican entre paréntesis, y los parámetros que la función devuelve son `x , y , z , ...` que se indican con la instrucción **return**.

En el caso de que la función no necesite recibir información, los paréntesis se deben dejar vacíos. Al ejecutar la función no hay que olvidarse de escribir estos paréntesis, incluso aunque estén vacíos. Es la forma que tiene Python de diferenciar variables de funciones:
"""

def saludar():
    print( "¡Hola! Que tengas un buen día :)")
 
print("A continuación se imprimirán tres saludos:")
saludar()
saludar()
saludar()

"""Noten que no siempre es necesario poner la instrucción **return** al final de la función. En este caso la función termina cuando finaliza el bloque indentado (con sangría).

Es importante tener en cuenta que la *definición* de la función no provoca ninguna acción, solamente le indica a la computadora que la próxima vez que se escriba el nombre de la función, esta debe realizar las instrucciones indicadas por la definición. En consecuencia, en preferible escribir todas las definiciones de funciones al inicio del programa, así estarán definidas para cuando se las quiera ejecutar más adelante.

Veamos un ejemplo:
"""

def suma(a, b):
    s = a + b
    return s

z = suma(3, 4)
print("3 + 4 =", z)

x = int(input("Ingrese el primer sumando: "))
y = int(input("Ingrese el segundo sumando: "))
z = suma(x, y)
print("x + y =", z)

"""En este ejemplo podemos ver que los nombres que le damos a las variables de input (`a, b`) son utilizados de forma interna a la función. Cuando ejecutamos la función con los valores `3` y `4`, las variables pasan a tomar estos valores y luego se ejecutan las instrucciones correspondientes. Cuando ejecutamos la función con los parámetros `x, y` lo que sucede es que `a` y `b` copian los valores de estas variables indicadas.

La instrucción **return** sirve para indicar el resultado que la función "devuelve". Una vez que se alcanza la instrucción **return** la función termina y devuelve el valor indicado. En general es preferible devolver información usando **return** antes que imprimirla usando **print** ya que esto permite reutilizar la función para una cantidad de casos mayor, donde no siempre quiero mostrar el resultado en pantalla, aunque queda a criterio de cada uno para lo que necesite.

Al concepto de función también podemos combinarlo con las estructuras que vimos previamente:
"""

def chequarContraseña(c):
    if c == "Secreto":
        resultado = True
    else:
        resultado = False
    return resultado


ingresado = input("Ingrese contraseña: ")        
while not chequarContraseña(ingresado):
    ingresado = input("Contraseña incorrecta. Ingrese de nuevo:")
else:
    print("Contraseña correcta.")

"""¿Se dieron cuenta que la forma que usamos para imprimir una variable es una función? **print**( ... ) lo que hace es llamar a una función ya creada que está en el estándar de Python y permite que mostremos el contendido que se le pase como parámetro a la función.

Incluímos un anexo al final de esta clase con una explicación introductoria de funciones con recursión, una técnica algo sofisticada que en algunos casos es de gran utilidad. No es necesario leerlo, es sólo para aquel que quiera conocer más acerca de esta técnica particular.

Además, al final de la clase podrán encontrar a modo de anexo, fragmentos de transmisiones en vivo de años anteriores que podrían ser de su interés.

La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

#### **Mini-desafío:** Funciones
1. Escribir una función que chequee los siguientes usuarios y contraseñas:
*  *Usuario:* Juan

 *Contraseña:* 12345_
*  *Usuario:* Pablo

 *Contraseña:* xDcFvGbHn

  La función debe recibir como parámetros el usuario y la contraseña, y debe devolver el valor True o False.

\
2. Escribir una función que recibe un número N y retorna la cantidad de divisores del mismo.

  *Ejemplos:*

  `contarDivisores(9) → 3`  (El número 9 tiene 3 divisores: 1, 3, 9)

  `contarDivisores(10) → 4` (El número 10 tiene 4 divisores: 1, 2, 5, 10)
"""

def login(usuario, contraseña):
  if (usuario == 'Juan' and contraseña == '12345_') or \
  (usuario == 'Pablo' and contraseña == 'xDcFvGbHn'):
    return True
  else:
    return False

#Primer intento de inicio de sesion 
print("Intento ingresar con los siguientes datos:")
print("Usuario: Hola")
print("Contraseña: Adios")
val = login('Hola','Adios')
print("Respuesta:", val)

print("\n")

#Segundo intento de inicio de sesion 
print("Intento ingresar con los siguientes datos:")
print("Usuario: Pablo")
print("Contraseña: xDcFvGbHn")
val = login('Pablo','xDcFvGbHn')
print("Respuesta:", val)

def contarDivisores (numero):
  contador = 1
  divisorAux = numero
  while divisorAux != 1:
    if numero % divisorAux == 0:
      contador += 1
    divisorAux -=1
  return (contador)


print(contarDivisores(9))
print(contarDivisores(10))
print(contarDivisores(2))

"""# $\color{\green}\blacktriangleright$ Desafío a Entregar: La conjetura del Dr. Lothar

*Los desafíos se entregan mediante [esta página](https://www.hackerrank.com/2022-1c-curso-introductorio-de-python) de HackerRank. Pueden ver un instructivo acerca del uso de la plataforma en [este link](https://youtu.be/pqYSwABnS_k).*


Escriba un programa que reciba un numero del usuario y repita el siguiente proceso usando un **while**:


*   Si el número es par, se debe dividir por $2$.
*   Si el número es impar, se debe multiplicar por $3$ y sumar $1$.

Este proceso se repite hasta llegar al numero $1$ y luego muestra en pantalla la cantidad de pasos que tardó en llegar.



**Ejemplos:**

- *Input:* `6`

  *Output:* `8` (Los pasos a seguir son: 6, 3, 10, 5, 16, 8, 4, 2, 1)

- *Input:* `13`

  *Output:* `9` (Los pasos a seguir son: 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)
"""



"""**Para un desafío mayor:** Resolver el problema aplicando funciones con recursión.

**Dato de color:**
* En 1937, [Lothar Collatz](https://es.wikipedia.org/wiki/Lothar_Collatz) [conjeturó](https://es.wikipedia.org/wiki/Conjetura_de_Collatz#Enunciado) que este proceso llega a 1 sin importar el número en el cual se empieza, pero hasta el día de hoy no se pudo demostrar su conjetura. Ya se comprobó usando programas de computadora que esto es verdad para todos los numeros menores que $2^{58}$. Sin embargo, no se encontró una prueba definitiva de que esta conjetura no falle para algún número más grande.

# Ejercitación integradora $\newcommand{\dif}{\bigstar}$$\newcommand{\facil}{\color{\green}{\dif}}$ $\newcommand{\pieceofcake}{\color{\cyan}{\dif}}$$\newcommand{\medio}{\color{\yellow}{\dif\dif}}$$\newcommand{\media}{\medio}$$\newcommand{\normal}{\medio}$  $\newcommand{\dificil}{\color{\orange}{\dif\dif\dif}}$ $\newcommand{\imposible}{\color{\red}{\dif\dif\dif\dif}}$
$\newcommand{\tarc}{\large\frown}$
$\newcommand{\arc}[1]{\stackrel{\tarc}{#1}}$
<head>
<style type="text/css">
  .img{ 
    display: block;
    margin-left:auto;
    margin-right:auto;
  }
  </style>
  </head>
  
A continuación les proponemos resolver algunos ejercicios integradores, este contenido servirá para poder practicar lo aprendido y de a poco acercarse a lo que podría ser una aplicación real. No se preocupen si no llegan a terminar todos, o si les cuestan más que los desafíos de la clase, es cuestión de tomarse el tiempo de leer, pensar, y probar diferentes ideas hasta que encuentren una posible solución al problema.

Luego de una semana les enviaremos una copia de las soluciones que se nos ocurrieron a nosotros para resolver estos problemas y poder comparar en caso de que lo deseen.

##$\facil$   Cálculo de promedio 
Cálcular la nota de un alumno es una tarea cotidiana de un profesor. Esta tarea suele realizarse a mano o en excel muchas veces. En esta ocasión la haremos en Python. 
- Escribir una función que calcule el promedio de 3 notas y entrege ese valor usando **return**.
- Reescribir la función anterior modificándola para asignar una importancia al primer examen de 20%, al segundo de 50% y al tercero de 30%.
- Llamar a cada función anterior 3 veces con distintas notas y verificar, mediante la instrucción **if**, si el alumno aprobó en cada caso (suponga que 4 es la nota de aprobación).
"""

# Promedio común
def promedio(n1,n2,n3):
    p = (n1+n2+n3)/3
    return p

# Promedio ponderado
def ponderado(n1,n2,n3):
    p = n1*0.2 + n2*0.5 + n3*0.3
    return p

if ponderado(3, 4, 5) >= 4:
  print("Aprobado")
else:
  print("Desaprobado")

if ponderado(1, 5, 10) >= 4:
  print("Aprobado")
else:
  print("Desaprobado")

if ponderado(4, 3, 5) >= 4:
  print("Aprobado")
else:
  print("Desaprobado")

"""##$\facil$ Una buena e-stimación
El número $e$ tiene inmensa utilidad para el análisis y la estadística, es una de las super-estrellas de la matemática, y su utilidad radica en que la función $e^x$  es igual a su derivada, por definición de $e$.

Gracias a las series de Taylor podemos obtener la siguiente definición del número $e$:

$e=1+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\frac{1}{4!}+\frac{1}{5!}+...$

Se pide obtener una aproximación del número $e$ calculando la suma de los primeros $20$ términos de esta serie.

**Tips:**
* $n! = 1\cdot 2\cdot 3 \cdot\ ...\ \cdot n$.
"""

def factorial(n):
  resultado = 1
  x = 2
  while x <= n:
    resultado *= x
    x += 1
  return resultado

e = 1
for n in range(1, 20):
  e += 1/factorial(n)

print(e)

"""##$\medio$   Test de primalidad 
Escribir una función que recibe un número y devuelve *True* si el número es primo y *False* en caso contrario.

Mediante un *for* verificar la *primalidad* de los numeros del $1$ al $20$, es decir, decidir si cada número es primo o no.

**Tips:**

* Un número $N$ es primo cuando tiene exactamente $2$ divisores ($1$ y $N$).
* Sin embargo, alcanza con verificar que no es múltiplo de ningún número entre $2$ y $\sqrt{N}$ (recordar que $\sqrt{N}=N^{0.5}$)
* El numero 1 **NO** es primo.
"""

def esPrimo(n):
  if n == 1:
    return False
  d = 2
  while d <= n**0.5:
    if n % d == 0:
      return False
    d = d + 1
  else:
    return True
  
for x in range(1, 21):
  print( x, "es primo?", esPrimo(x) )

"""## $\normal$ La leyenda de Filius Bonacci  

<img class="img" src="https://upload.wikimedia.org/wikipedia/commons/9/93/Fibonacci_spiral_34.svg" height="200" alt = "Espiral Fibonacci" title = "">

Imprimir los primeros $n$ números de la [sucesión de Fibonacci](https://es.wikipedia.org/wiki/Sucesi%C3%B3n_de_Fibonacci).


```
0, 1, 1, 2, 3, 5, 8, 13, 21 ...
```
"""

a0 = 0
a1 = 1
n = 10
for i in range(n):
    if i%2==0:
        print(a0)
        a0+=a1
    else:
        print(a1)
        a1+=a0

"""## $\normal$ Adivina adivinador
<img class="img" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/numbers.jpg" height="200" alt = "Akinator numérico" title = "Akinator">

Se rumorea que al rector de una universidad le apasiona adivinar números. Cuando se cruza a alguien, ya sean alumnos o profesores, les pide que piensen un número. Luego, intenta adivinarlo mientras el alumno le indica si el número es mayor, menor o igual al que el rector esta adivinando. 

Ahora les proponemos a ustedes realizar el programa que adivine un número que ustedes elijan, indicándole si los números que este propone son mayores o menores al elegido.

Ustedes pensarán en un número secreto (para este ejercicio consideremos que el número es menor a 10.000), luego el programa intenta adivinarlo. El usuario debe responder con el símbolo `>`, `<` ó `=`. En el caso de ser igual, el programa termina e imprime la cantidad de intentos que tardó, caso contrario, debe volver a intentar adivinar el número y se repite el procedimiento.

**Desafío:** Encontrar la estrategia que puede ejecutar la máquina para adivinar el número en la menor cantidad de intentos posible.
"""

# Versión mejorada: El número cambia de a 10 hasta estar cerca, luego cambia de a 1

numero = 50
respuesta = ''
turnos = 0

ultima_respuesta = ''
salto = 10

while respuesta != '=':
  print("Estoy pensando en el numero:", numero)
  respuesta = input("¿Tu numero es >, < o = ? ")

  if respuesta == '<':
    if ultima_respuesta == '>':
      salto = 1
    numero = numero - salto
    ultima_respuesta = '<'

  elif respuesta == '>':
    if ultima_respuesta == '<':
      salto = 1
    numero = numero + salto
    ultima_respuesta = '>'
 
  turnos += 1

print("Tardé", turnos, "turnos en adivinar.")

"""##$\dificil$  Dominó  

El [Dominó](https://es.wikipedia.org/wiki/Domin%C3%B3) es un juego de mesa muy popular. 
En este ejercicio no vamos a programar un juego de Domino, pero sí contar sus fichas.
<center>
<img src="https://es.calcuworld.com/wp-content/uploads/sites/2/2018/04/cantidad-de-fichas-domino.jpg" height="200" alt = "Fichas domino desparramadas sobre una mesa">
</center>

A pesar de que el domino tradicional se juega con fichas hasta el número 6, vamos a considerar un juego de fichas de valor máximo $n$.

- Escribir una función que calcule la cantidad de fichas para un juego de dominó completo con fichas que contienen hasta el número $n$.
Nota: ¡No hay fichas repetidas! 2-4 es la misma ficha que 4-2. ¡Observar que en el dominó hay fichas con valor 0!

```
   cantidadFichas(3)
   >>> 10
   cantidadFichas(4)
   >>> 15
```

- Escribir una función que muestre todas las fichas para un juego de dominó como el anterior, en cualquier orden.

```
   mostrarFichas(3)
   >>> 0-0
   >>> 0-1
   >>> 0-2
   >>> 0-3
   >>> 1-1
   >>> 1-2
   >>> 1-3
   >>> 2-2
   >>> 2-3
   >>> 3-3
```

- Escribir una función que, dada una cantidad de fichas, calcule cuál es el $n$ (valor máximo) de las fichas. Si el número de fichas no corresponde a la cantidad de fichas de ningún juego de dominó completo retornar -1.

```
   valorMaximo(10)
   >>> 3
   valorMaximo(11)
   >>> -1
   valorMaximo(15)
   >>> 4
```
- Llamar a las funciones anteriores con distintos valores para corroborar su funcionamiento
"""

def cantidadFichas(n):
    print((n + 1) * (n + 2) // 2)
    
def mostrarFichas(n):
    for i in range(0, n + 1):
        for j in range(i, n + 1):
            print(str(i) + '-' + str(j))
            
def valorMaximo(num):
    n = 1
    while (n + 1) * (n + 2) / 2 < num:
        n += 1
    if (n + 1) * (n + 2) / 2 == num:
        print(n)
    else:
        print(-1)

"""##$\dificil$ El ejercicio más integrador

Se pide calcular una integral definida en un intervalo de una función genérica.

En lugar de obtener un resultado exacto, realizaremos una aproximación del resultado aplicando la integral de Riemann. Para lograr esto vamos a aproximar una función mediante muchos rectángulos muy angostos. Para obtener el resultado de la integral vamos a sumar el área de todos estos rectángulos entre cierto intervalo $[a, b]$:

![Riemann1](https://upload.wikimedia.org/wikipedia/commons/a/af/Riemann_Integration_4.png)

Primero debemos elegir un número $\Delta x$ cuyo valor sea muy pequeño, y que determina el ancho de los rectángulos. Comenzando del límite de integración inferior $a$ obtendremos el primer área como $f(a)\cdot \Delta x$, luego el siguiente área será $f(a+\Delta x)\cdot \Delta x$ , el tercer área es $f(a+2\cdot\Delta x)\cdot \Delta x$ , y así se sigue mientras no se supere $b$.

Al elegir un valor más chico de $\Delta x$ se obtiene una mejor aproximación:

![Riemann2](https://upload.wikimedia.org/wikipedia/commons/3/34/Riemann_Integration_5.png)

Se debe programar la función *integral(f, a, b, dx)* en la cual *f* sea la función a integrar (la función *f* debe recibir como parámetro un número *x*, debe entregar el resultado usando *return*), *a* y *b* sean los límites de integración, y *dx* sea el ancho de los rectángulos.

\

Para que una función reciba como parámetro otra función, simplemente se la puede tratar como a una variable más:

```python
def f1(x):
  return 2*x + 1
 
def f2(x):
  return 3*x - 2
 
def suma_de_funciones(y1, y2, x):
  return y1(x) + y2(x)

print(suma_de_funciones(f1, f2, 5))
```

**Ejemplo:**

```python
#def integral(f, a, b, dx):
#  ...
#  return ...

def f(x):
  return 2*x + 1

# Integral desde 0 hasta 1 con pasos de 0.0001
print( integral(f, 0, 1, 0.0001) )
```

El resultado debería ser 2, sin embargo debido a la precisión del método se obtiene:
```
1.9998999999999203
```

"""

def f1(x):
  return 1

def f2(x):
  return x

def f3(x):
  return x**2 - 3*x

def integral(f, a, b, dx):
  resultado = 0
  x = a
  while (x + dx) <= b:
    resultado += f(x) * dx
    x += dx
  return resultado

print( integral(f1, 10, 15, 0.0001) )
print( integral(f2, 1, 2, 0.0001) )
print( integral(f3, 0, 3, 0.0001) )

"""##$\dificil$ Locos por las matemáticas 
En marzo 2019, Emma Haruka Iwao, una empleada de Google, logró calcular 31,4 trillones de dígitos del famoso número pi en 121 dias usando el poder de la nube de Google. ¡Hoy ustedes pueden hacer lo mismo con la ayuda de Python!

Aprovechando el descubrimiento del matemático indio Sriniviasa Ramanujan (1910) podemos emplear nuestro propio aproximador de pi.
$$ \frac{1}{\pi}= \frac{2\sqrt{2}}{9801}\sum_{k=0}^{\infty} \frac{(4k)! \cdot (1103+26390k)}{(k!)^4 396^{4k}}$$

**Tips**:

* Pueden utlizar la siguiente función para calcular factoriales:

```python
def factorial(n):
  return 1 if n<=1 else n*factorial(n-1)
```
$$\textrm{factorial(4)}=4!=24 $$

* Esto es un problema abierto. No es posible conseguir una representación decimal exacta de $\pi$, por lo tanto solo se puede estimar.



Si no estamos tan locos por la matemáticas podemos usar otras aproximaciones más simples como:

$$\pi \approx \frac{22}{7} \approx \frac{355}{113} $$

Otros números famosos:
$$e = \sum_{k=0}^\infty \frac{1}{k!} \qquad e=\lim_{x\rightarrow\infty} \left( 1+\frac{1}{x} \right)^x \qquad \varphi = \frac{1+\sqrt{5}}{2} $$
"""

def factorial(n): # esto es una función recursiva
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)
    
def piApprox(num): 
    mul = 2**(3/2)/9801
    suma = 0
    for k in range(num):
        suma += factorial(4*k) /factorial(k)**4 *(1103+26390*k)/396**(4*k)
    return 1/(mul*suma)

print(piApprox(10))

"""# Anexo A: Funciones con recursión
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

A pesar de ser un curso introductorio, nos parece oportuno comentar una técnica bastante útil en programación, aunque puede ser compleja. No va a ser necesario entender esto para las proximas clases así que queda para los que estén interesados.

Esta técnica es la de ejecutar una función dentro de sí misma, la técnica se llama **recursión** y se ve similar a esto:

```python
def f(a):
  ...
  f(b)
  ...
  return
```

Esta técnica puede simplificar algunas tareas, pero a la vez ser peligrosa. El riesgo de que una función se llame a sí misma es que este proceso ocurra indefinidamente, si la función "externa" llama a la función "interna", y la función "interna" vuelve a llamarse a sí misma, y esta vuelve a llamarse a sí misma, etc, sin frenos. Se puede pensar como unas muñecas rusas infinitas en las que cada una contiene a otra y nunca se llega a un núcleo.

Es por esto que **antes** del llamado a sí misma debemos programar una condición de corte, que eventualmente detenga el proceso de recursión y cada función alcance su instrucción **return** y termine.

Veamos un ejemplo clásico: Crear una función que calcule el factorial de un número. El factorial de un número $n$ es el producto de todos los números entre $1$ y $n$. Se suele denotar con un signo de exclamación, de la siguiente forma: $n! = 1\cdot 2\cdot 3 \cdot\ ...\ \cdot n$.

Solución **sin** recursión:
"""

def f(n):
  resultado = 1
  for x in range(1, n+1):
    resultado *= x
  return resultado

print("10! =", f(10) )

"""Para resolver el problema aplicando recursión podemos observar que el factorial de $n$ se puede obtener a partir del factorial de $n-1$:

$n! = n\cdot (n-1)!$

Además si $n$ es menor o igual a 2, entonces $n!=n$

Aplicando esta reducción del problema, y la condición de corte, podemos llegar a la siguiente implementación:
"""

def f(n):
  if n <= 2:
    return n
  else:
    return n * f( n-1 )

print("10!", f(10) )

"""En este ejemplo simple, no parece que usar recursión aporte mucho, pero la técnica es muy útil en problemas más complejos como algoritmos de ordenamiento, de búsqueda, entre otros.

# Anexo B: Tips extra de Python
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

A continuación les dejamos un fragmento de una transmisión en vivo de años anteriores, en la cual se explican diversos trucos y funciones que tiene Python, los cuales no fueron abordados en la clase pero que pueden serles de utilidad en ciertos casos.

Temas:
* Tips para usar *print( )*.
* Control de flujo en una sola línea.
* Operadores ternarios.
* break, continue, pass.
"""

# Link a Youtube: https://www.youtube.com/watch?v=fBxP413Nxk4

from IPython.display import YouTubeVideo
YouTubeVideo('fBxP413Nxk4', start=1685, end=3316, width=800, height=450)

"""# Anexo C: Caso de aplicación de Python a la Ingeniería Electrónica
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

A continuación les dejamos un fragmento de una transmisión en vivo de años anteriores, en la cual se relata un caso de aplicación de Python a la Ingeniería Electrónica.
"""

# Link a Youtube: https://www.youtube.com/watch?v=fBxP413Nxk4

from IPython.display import YouTubeVideo
YouTubeVideo('fBxP413Nxk4', start=269, end=900, width=800, height=450)