# -*- coding: utf-8 -*-
"""Copia de Clase 3 - IntroducciÃ³n a la ProgramaciÃ³n con Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/112w5vhayTLRsGF-W8kqeVSc14EMhA8UQ

# Clase 3

##IntroducciÃ³n 

En las clases anteriores aprendimos a trabajar con diferentes tipos de variables, funciones, operadores y listas.
En esta clase nos vamos a enfocar en otras estructuras de datos, algo mÃ¡s complejas pero de mucha utilidad. Suele pasar que un problema dÃ­ficil de resolver con cierta estructura, se vuelve mucho mÃ¡s simple utilizando otra distinta. Por eso es importante aprender a aplicar la herramienta correcta para cada problema, y de esa forma organizar nuestros datos y utilizarlos de la manera mÃ¡s prÃ¡ctica y eficiente.

\

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/data_structures_2.png" alt = "Diagrama de distintas estructuras de datos" height = 300>

## Tuplas

Las tuplas son similares a las listas, pero a diferencia de ellas se dice que las tuplas son *inmutables*, esto quiere decir que sus elementos no pueden cambiar una vez definidos. Se pueden crear usando parÃ©ntesis de la siguiente manera:

> a = **(** $ a_{0}, a_{1}, a_{2},\dots $ **)**

Los elementos de una tupla se pueden acceder usando un Ã­ndice entre corchetes. Al igual que las listas admiten *slicing*.

Cuando creamos una funciÃ³n que devuelve mÃ¡s de un elemento separado por comas, estamos utilizando una tupla inadvertidamente. Cuando intercambiamos 2 elementos de una lista como en los ejemplos de la clase anterior, tambiÃ©n aparecen tuplas. Estas son las principales aplicaciones de tuplas, y para concentrarnos en las principales estructuras de datos de Python no ahondaremos en este tema.
"""

tupla = (1, 2, 3)
print(tupla)
print(tupla[0], tupla[1], tupla[2])

# Sacando el primer numeral, la siguiente lÃ­nea produce un error
#tupla[0] = 10   # Las tuplas NO admiten la asignaciÃ³n por Ã­ndice

def f(x):
  return x, 2*x, 3*x

print(f(10))

x, y, z = f(10)
print(x, y, z)

x, y, z = z, 0, x
print(x, y, z)

"""## Diccionarios"""

# Link a Youtube: https://youtu.be/Y8eTehVX8fg
# Tema: Diccionarios, cÃ³mo estan construidos, operaciones y mÃ©todos.

from IPython.display import YouTubeVideo
YouTubeVideo('Y8eTehVX8fg', width=800, height=450)

"""Un diccionario es otra estructura de datos muy Ãºtil y muy utilizada cotidianamente. La analogÃ­a directa que se suele hacer para explicar diccionarios en programaciÃ³n hace referencia a los diccionarios fÃ­sicos. Un diccionario (fÃ­sico) contiene una gran cantidad de informaciÃ³n organizada por palabras y contenido asociado a ellas. MÃ¡s precisamente, cada una de las palabras, ordenada alfabÃ©ticamente, tiene informaciÃ³n asociada que describe en profundidad su significado. Lo que nos interesa obtener de un diccionario son las definiciones, y la palabra correspondiente es lo que nos ayuda a encontrarlas.

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/pydict.png" alt = "Dictionary PNG" height = 200 title="Diccionario">

En programaciÃ³n los diccionarios no son muy distintos. Un "diccionario" en este contexto es una estructura de datos cuya informaciÃ³n esta organizada igual que en un diccionario fÃ­sico. cada bloque de informaciÃ³n, es decir, cada elemento, tiene asociada una palabra. La palabra que se utiliza para encontrar el bloque de informaciÃ³n se la suele denominar **key** Ã³ **clave**. Mediante la **clave** se puede acceder a dicha informacion, la cual se suele denominar **contenido**. El par **clave, contenido** suele llamarse **elemento**.

Es muy importante notar que no pueden existir dos elementos con igual clave, estos serÃ­an indistinguibles.

La clave suele ser informaciÃ³n con tipo de dato string (aunque no necesariamente), mientras que el contenido puede tener cualquier tipo de dato. Los diccionarios se crean utilizando la siguiente estructura:

> x = **{**  $k_{0}$ **:** $c_{0}$**,** $k_{1}$ **:** $c_{1}$, $\dots$**}**
>
> Noten que el "**:**" divide el *key* del *contenido* en cada *elemento*, la "**,**" separa cada par y se enmarca todo entre llaves: **{ }**

Comenzemos por crear un diccionario con la descripciÃ³n de las palabras:
"""

d = {
    "trueno": "Ruido muy fuerte que sigue al rayo durante una tempestad, \
producido por la expansiÃ³n del aire al paso de la descarga elÃ©ctrica.",
    "rayo": "Chispa elÃ©ctrica de gran intensidad producida por la descarga \
entre dos nubes o entre una nube y la tierra."
} 

a = {} # Diccionario vacÃ­o

print(d)
print(a)

"""Para acceder a los datos de un diccionario se utiliza la misma sintaxis que las listas pero en lugar de un *Ã­ndice* numÃ©rico, utilizando la *clave* a la que queremos acceder."""

d = {
    "trueno": "Ruido muy fuerte que sigue al rayo durante una tempestad, \
producido por la expansiÃ³n del aire al paso de la descarga elÃ©ctrica.",
    "rayo": "Chispa elÃ©ctrica de gran intensidad producida por la descarga \
entre dos nubes o entre una nube y la tierra."
}

print('rayo:')
print(d['rayo'])

"""Tambien podemos usar los diccionarios para acceder de forma sencilla a datos almacenados. Por ejemplo, para acceder a los estudiantes de una universidad a partir de su nÃºmero de legajo, creamos una base de datos estructurada de la siguiente manera:

> **clave**=Legajo **contenido**=Nombre
"""

database = {
    50001:"Karen Fernandez",
    50002:"MatÃ­as Perez",
    50003:"Julieta Gonzalez"
}
print("Nombre completo del legajo", 50002, ":", database[50002])

"""### Operaciones con diccionarios
- clave **in** diccionario: Nos permite saber si esa clave se encuentra en el diccionario.
"""

database = {
    50001:"Karen Fernandez",
    50002:"MatÃ­as Perez",
    50003:"Julieta Gonzalez"
}

if 50001 in database:
    print("la clave 50001 se encuentra en el diccionario")

clave = int(input())
if clave in database:
    print(clave, 'estÃ¡ en el diccionario')
else:
    print(clave, 'no estÃ¡ en el diccionario')

"""- **for** clave **in** diccionario: Nos permite iterar por todas las claves del diccionario."""

database = {
    50001:"Karen Fernandez",
    50002:"MatÃ­as Perez",
    50003:"Julieta Gonzalez"
}

for clave in database:
    print('La clave',clave,'tiene asociado el valor',database[clave])

"""- **.items**(): Devuelve la lista de claves y valores almacenadas en el diccionario.

 Ya que se obtienen 2 datos por elemento, para utilizarlo en un *for* tendremos que indicar 2 nombres de variable separados por coma. En este ejemplo la variable *k* tomarÃ¡ el valor de la *key* de cada elemento y la variable *c* tomarÃ¡ el valor de cada *contenido*.
"""

database = {
    50001:"Karen Fernandez",
    50002:"MatÃ­as Perez",
    50003:"Julieta Gonzalez"
}

# Pueden quitar el comentario de la siguiente lÃ­nea y ver quÃ© imprime
# print(database.items())

for k,c in database.items():
    print("key:", k," content: ",c)

# Otra forma

for item in database.items():
    print("key:", item[0]," content: ",item[1])

"""

* diccionario**[** clave **]** = valor: Agrega un nuevo elemento a un diccionario. Si ya existÃ­a un valor asociado a esta clave, serÃ¡ reemplazado por el nuevo valor.
"""

x = {
    'aÃ±o':2021,
    'mes':12
}

x['dia'] = 24
print(x)

x['mes'] = 'Diciembre'
x['horas'] = 23
x['minutos'] = 59
print(x)

"""- **.get**( clave, valor_por_defecto ): Devuelve el valor asociado a la clave. Si la clave *no* se encuentra el diccionario, devuelve el valor por defecto indicado. Esto es Ãºtil cuando no sabemos si una clave existe o no."""

texto = "lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod \
tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, \
quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi \
consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore \
eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt \
in culpa qui officia deserunt mollit anim id est laborum."

ocurrencias = {}
for letra in texto:
  if letra.isalpha(): # Solo importan letras, no comas, puntos, espacios, etc.
    letra = letra.upper() # No nos importa si es minÃºscula o mayÃºscula
    # Suma 1 a las ocurrencias de 'letra', o inicializa el elemento
    ocurrencias[letra] = ocurrencias.get(letra, 0) + 1

# De esta forma averiguamos la cantidad de ocurrencias de cada letra.
for k,c in ocurrencias.items():
    print("La letra", k, "aparece", c, "vez/veces.")

"""#### **Mini-desafÃ­o:** Diccionarios
1. Realizar un programa que pida al usuario un nÃºmero de legajo y el nombre completo, luego los guarde en un diccionario. En caso de que el nÃºmero de legajo ya se encuentre en el diccionario, se debe mostrar un mensaje de advertencia.

 Usar dos celdas de cÃ³digo, en una crear el diccionario, y en la otra agregar el nombre y legajo y mostrar el contenido total. La idea es que cuando se ejecute varias veces la segunda celda se agrege un nuevo nombre y legajo a lo que ya habÃ­a sido almacenado en el diccionario.
"""

# Celda 1
# Ejecutar esta celda 1 vez para crear el diccionario vacÃ­o
dic = {}
print(dic)

# Celda 2
# Ejecutar esta celda cada vez que se quiera agregar un elemento

legajo = int(input("Ingrese el numero de legajo: "))
nombre = input("Ingrese el nombre completo: ")

if legajo in dic:
  print("Ese alumno ya esta registrado.")

else:
  dic[legajo] = nombre

print(dic)

"""2. Realizar un programa que decodifique [cÃ³digo morse](https://es.wikipedia.org/wiki/C%C3%B3digo_morse). El usuario debe ingresar una palabra en cÃ³digo morse, usando una secuencia de puntos, guiones y espacios como la siguiente:

  ```.--. .-. --- --. .-. .- -- .- -.-. .. --- -.```
  
  Luego, separando por espacios, cada letra debe ser convertida de morse a una letra del alfabeto, y por Ãºltimo la traducciÃ³n se muestra en pantalla como un *string*. Les proponemos definir un *diccionario* que ayude a realizar la traducciÃ³n. Es importante considerar quÃ© dato serÃ¡ la clave, y cuÃ¡l el contenido, de forma en que les sea mÃ¡s Ãºtil para lograr resolver el desafÃ­o.

  **Tips:** Revisar los mÃ©todos `.split()` y `.join()` para convertir entre strings y listas.
"""

# SoluciÃ³n

morse_code = {'.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', 
              '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', 
              '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', 
              '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', 
              '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', 
              '--..': 'Z'}

frase = '.--. .-. --- --. .-. .- -- .- -.-. .. --- -.'

letras = frase.split()

for i in range(len(letras)):
  letras[i] = morse_code[letras[i]]

print( ''.join(letras) )

"""### Nota final
Es importante ver que un diccionario tiene un cierto orden, al igual que las listas. Por otro lado, tambiÃ©n aceptan contenidos repetidos y todo marcharÃ¡ correctamente siempre que no se repitan las claves. Uno de los dilemas mÃ¡s comunes cuando se trabaja con grandes volÃºmenes de informaciÃ³n es quÃ© tomar como clave.

En la prÃ³xima secciÃ³n veremos un tipo de datos que ya no organizarÃ¡ la informaciÃ³n de manera tal que exista un orden establecido. En algunos casos es provechoso que la informaciÃ³n se estructure de manera tal que no exista un orden en los elementos.

## Sets
"""

# Link a Youtube: https://youtu.be/EAyOH2EwI3w
# Tema: Sets, cÃ³mo estan construidos, operaciones y mÃ©todos.

from IPython.display import YouTubeVideo
YouTubeVideo('EAyOH2EwI3w', width=800, height=450)

"""Un **set** es una estructura de datos mÃ¡s avanzada que las anteriores, la cual nos permite almacenar un grupo de elementos cuyo orden no es relevante. Lo Ãºnico que tiene importancia cuando utilizamos un **set** es quÃ© elemento estÃ¡ y quÃ© elemento no. 

<img src="https://files.realpython.com/media/t.8b7abb515ae8.png" height = 200 alt = "RepresentaciÃ³n de Set usando diagrama Venn" title= "A&B">


Un **set** no admite repetidos, ya que por su funcionamiento interno no tiene la capacidad de determinar cuando un elemento se encuentra mÃ¡s de una vez. Solo se puede saber quÃ© elementos estÃ¡n y quÃ© elementos no.
A primera vista parecerÃ­a entonces que un **set** es muy limitado, ya que no estÃ¡ ordenado y no acepta repetidos. No obstante, este es muy prÃ¡ctico para algunos tipos de operaciones, las cuales serÃ­an muy tediosas de  programar en listas o diccionarios.

Para crear un **set** se utilizan llaves **{ }** y se colocan elementos separados por comas, su sintaxis es similar a la de las listas.

"""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}   # Los sets no admiten elementos repetidos
print("Set x =", x)

"""### Operaciones con sets
- **|** : Es la operacion de $A \cup B$ llamada "*uniÃ³n*".
"""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
z = {15, 20}

k = x | y | z
print(k)

"""
-  **&**: Es la operacion de $A \cap B$ llamada "*intersecciÃ³n*"."""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
w = x & y
print(w)

"""- **A-B**: todo elemento de A que tambiÃ©n se encuentre en B, serÃ¡ quitado de A. El equivalente logico es $ A\cap \neg B$."""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
z = x - y
print(z)
print(y - x)

"""- **.remove**($valor$): Remueve el valor del set."""

x = {1, 2, 3, 4, 7}
x.remove(1)
print(x)

"""- **.add**($valor$): Agrega el valor al set."""

x = {1, 2, 3, 4, 7}
x.add("hola")
print(x)

"""- **len**($set$) Obtiene el tamaÃ±o de un set."""

conjunto = {1, 2, 1, 3, 1, 6}
print(conjunto)
print(len(conjunto))

"""- **.issubset**($set$): Analiza si un set estÃ¡ contenido dentro de otro."""

x = {1, 2, 3, 4, 5, 6, 7, 8, 9}
y = {8, 9, 10}
z = {4, 8}


print(z.issubset(x))
print(y.issubset(x))

"""#### **Mini-desafÃ­o:** Sets
1. Se cuentan con varios sets que contienen nombres de personas a las que les gusta un cierto sabor de helado:

  ```python
vainilla = { "Juan", "Marina", "Tomas", "Paula" }
chocolate = { "Pedro", "Paula", "Marina" }
dulceDeLeche = { "Juan", "Julian", "Pedro", "Marina" }
```

  Responder, usando operaciones de sets:

  - Â¿Hay alguna persona a la que le gusten todos los sabores?

  - Â¿Hay alguna persona a la que le guste la vainilla y no el dulce de leche?

  - Â¿CuÃ¡ntas personas distintas tenemos?


2. DiseÃ±ar un programa que analiza si una frase es un [pangrama](https://es.wikipedia.org/wiki/Pangrama) del idioma inglÃ©s, es decir, si contiene todas las letras del alfabeto al menos 1 vez. El programa debe ser capaz de ignorar espacios y signos de puntuaciÃ³n. Por ejemplo:
```python
frase = "the quick brown fox jumps over the lazy dog"
```
  El siguiente set puede serles de utilidad:
  ```python
  letras = set("abcdefghijklmnopqrstuvwxyz")
  ```
"""

# SoluciÃ³n - parte 1

vainilla = {"Juan", "Marina", "Tomas", "Paula"}
chocolate = {"Pedro", "Paula", "Marina"}
dulceDeLeche = {"Juan", "Julian", "Pedro", "Marina"}

print("Le gustan todos los sabores a:", vainilla & chocolate & dulceDeLeche)

print("Le gusta la vainilla y no el dulce de leche a:", vainilla - dulceDeLeche)

print("Total de personas:", len(vainilla | chocolate | dulceDeLeche))

# SoluciÃ³n - parte 2

letras = set("abcdefghijklmnopqrstuvwxyz")

frase = input("Ingrese una frase: ")

if letras.issubset( set(frase) ):
  print("La frase es un pangrama del idioma inglÃ©s!")
else:
  print("La frase no es un pangrama.")

"""## LibrerÃ­as

Como Ãºltimo tÃ³pico del curso, hablaremos del uso de librerÃ­as y mostraremos diversos ejemplos. No es para que se los aprendan de memoria, sino para que conozcan estas herramientas y puedan aprender a utilizar nuevas librerÃ­as en el futuro, en base a sus necesidades particulares.

"""

# Link a Youtube: https://youtu.be/frIIOnzvdHs
#Tema: LibrerÃ­as: concepto, instalaciÃ³n, importaciÃ³n y ejemplos. 

from IPython.display import YouTubeVideo
YouTubeVideo('frIIOnzvdHs', width=800, height=450)       #Video LibrerÃ­as

"""Una *librerÃ­a* o *biblioteca* es un conjunto de funciones implementadas por otro programador que nos facilitan realizar tareas, principalmente porque no debemos volver a programar este cÃ³digo. 

<img src="http://www.goalexandria.com/wp-content/uploads/2016/02/alt-lib.png" width=200px>

*Â¿Como usamos una librerÃ­a?* Primero debemos importarla, para lo cual tenemos opciones. A continuaciÃ³n, se expone la sintaxis general junto con un ejemplo:

* OpciÃ³n 1: importar una librerÃ­a, sin alias.

  > **import** (nombre de la libreria) 

  ```python
  import math

  ```

* OpciÃ³n 2: importar una librerÃ­a, con alias.

  > **import** (nombre de la libreria) **as** (nombre abreviado)

  ```python
  import pandas as pd

  ```

Las librerÃ­as muchas veces estÃ¡n separadas en distintos mÃ³dulos. PodrÃ­amos decir que la librerÃ­a es como un estante de libros, y en cada libro se encuentran las funciones de un tema en comÃºn, incluso un "libro" podrÃ­a estar subdividido en "capÃ­tulos". Es decir, los distintos mÃ³dulos de una librerÃ­a podrÃ­an llegar a estar subdivididos en mÃ³dulos, y cada mÃ³dulo podrÃ­a estar nuevamente subdividido.

Si lo que queremos son mÃ³dulos o funciones particulares de una librerÃ­a, podemos importar de a uno o mÃ¡s de diversas formas.

* OpciÃ³n 1: importar un mÃ³dulo o funciÃ³n, sin alias.

  > **from** (nombre de la libreria) **import** (nombre de un mÃ³dulo)

  ```python
  from random import randint

  ``` 

* OpciÃ³n 2: importar mÃ¡s de un mÃ³dulo o funciÃ³n.

  > **from** (nombre de la libreria) **import** (nombre de un mÃ³dulo), (nombre de otro mÃ³dulo), ...

  ```python
  from random import randint, randrange

  ``` 

* OpciÃ³n 3: importar un mÃ³dulo o funciÃ³n, con un alias.

  > **from** (nombre de la libreria) **import** (nombre de un mÃ³dulo) **as** (nombre abreviado)

  ```python
  from matplotlib import pyplot as plt

  ``` 

* OpciÃ³n 4: importar un mÃ³dulo o funciÃ³n, con un alias, otra forma.

  > **import** (nombre de la libreria)**.**(nombre de un mÃ³dulo) **as** (nombre abreviado)

  ```python
  import matplotlib.pyplot as plt

  ``` 

* OpciÃ³n 5: importar todos los mÃ³dulos o funciones de una librerÃ­a.

  > **from** (nombre de la librerÃ­a) **import** * (todo)

  ```python
  from numpy import *

  ``` 

Una vez importada la librerÃ­a, podremos utilizar las funciones y variables definidas en ella. La utilizaciÃ³n de una funciÃ³n o variable dependerÃ¡ de cÃ³mo hayamos realizado la importaciÃ³n. Ejemplos:

* Si se importÃ³ una librerÃ­a o mÃ³dulo:
  > (nombre de la libreria/mÃ³dulo)**.**funciÃ³n*(argumentos)*

  > (nombre de la libreria/mÃ³dulo)**.**(nombre de la variable)

  ```python
  import math

  print(math.sin(math.pi / 2))

  ```

* Si se importÃ³ una funciÃ³n o variable:
  > funciÃ³n(argumentos)

  > variable 

  ```python
  from math import sin, pi

  print(sin(pi / 2))

  ```

* Si se importÃ³ una librerÃ­a dividida en mÃ³dulos:

  > (nombre de la libreria)**.**(nombre del mÃ³dulo)**.**funciÃ³n*(argumentos)*

  ```python
  import matplotlib

  datos = [i for i in range(-10, 10)]
  print(matplotlib.pyplot.plot(datos, datos))

  ```


**Notas:**
- No es obligatorio especificar un nombre abreviado con **as**, puede utilizarse una librerÃ­a con su nombre original omitiendo este comando.
- No sÃ³lo pueden importarse mÃ³dulos de una librerÃ­a, sino tambiÃ©n funciones sueltas, segÃºn lo que necesiten. Siempre tengan cuidado de que los nombres de funciÃ³n sean Ãºnicos. Si importan una funciÃ³n directamente entonces no querrÃ¡n definir su propia funciÃ³n con el mismo nombre.
- Es una buena prÃ¡ctica que todas las librerÃ­as se importen al principio del programa, o sea que las instrucciones de **import** se encuentren arriba de todo.


**Ejemplos:**
"""

import math  # Importamos la libreria math

print('El seno de 0 es ', math.sin(0), 'y el coseno', math.cos(0))

from math import sin, cos  # Importamos directamente las funciones que usaremos 
print('El seno de 0 es ', sin(0), 'y el coseno', cos(0))

import math as m  # Importamos la libreria math abreviada como m

print('El seno de 0 es ', m.sin(0), 'y el coseno', m.cos(0))

# En este caso usamos el mÃ³dulo 'path' de la librerÃ­a 'os' y lo apodamos 'pth'
from os import path as pth

print(pth.join('Carpeta','Archivo.rar'))

"""Algunas librerÃ­as muy conocidas y utilizadas son:


*   [numpy](https://numpy.org/) (CÃ¡lculo matricial)
*   [pandas](https://pandas.pydata.org/) (Lectura de bases de datos)
*   [maplotlib](https://matplotlib.org/) (GrÃ¡ficos)
*   [tkinter](https://docs.python.org/3/library/tk.html) (Interfaces grÃ¡ficas)
*   [Qt](https://www.qt.io/qt-for-python) (Interfaces grÃ¡ficas)
*   [scipy](https://www.scipy.org/) (Ciencia de datos)
*   [scikit-learn](https://scikit-learn.org) (Machine Learning)
*   [TensorFlow](https://www.tensorflow.org/) (Machine Learning avanzado)

En IEEE-ITBA ofrecemos un curso mÃ¡s avanzado como continuaciÃ³n de este curso introductorio, en donde se utiliza **Pandas** para analizar archivos de informaciÃ³n estructurada, como lo es el formato de hojas de datos de **Excel**, y **Matplotlib** para realizar grÃ¡ficos y visualizar informaciÃ³n. Pueden enterarse de novedades respecto a todos nuestros eventos a travÃ©s de nuestra cuenta de [Instagram](https://www.instagram.com/ieee.itba/).


A continuaciÃ³n les ofrecemos un conjunto de ejemplos con diversas librerÃ­as. Por supuesto que para cada una de ellas existen muchas mÃ¡s cosas al respecto, pero esperamos que les ayude a tener una mejor idea del tipo de herramientas que existen, y que se animen a buscar nuevas librerÃ­as cuando tengan que solucionar problemas especÃ­ficos. Algunas de estas librerÃ­as ya vienen incluÃ­das con la instalaciÃ³n de Python mientras que otras deben ser instaladas de forma independiente. En [este link](https://docs.python.org/3/library/) pueden investigar acerca de todas las librerÃ­as estÃ¡ndar que trae Python.

Si cierta librerÃ­a no se encuentra instalada en el sistema, entonces el comando *import* para esa librerÃ­a no funcionarÃ¡. Usando la herramienta **pip** se pueden instalar librerÃ­as nuevas. En este ejemplo, al ejecutar el siguiente bloque de cÃ³digo se instalan las librerÃ­as *numpy* y *pandas* en el entorno de Google Colab.
"""

! pip install numpy
! pip install scipy

"""#### [copy](https://docs.python.org/3/library/copy.html)

* *Copiado en profundidad de estructuras de datos*

Por defecto Python NO copia estructuras de datos, para ahorrar memoria:
"""

A = [1, 2, 3]
B = A
B += [4, 5, 6]

# No modificamos directamente A, sin embargo su valor cambiÃ³
# En este caso, 'B' es un nombre alternativo de 'A', no es una copia
print(A)
print(B)

"""Usando el mÃ©todo **.copy()** realizamos una copia real:"""

A = [1, 2, 3]
B = A.copy()
B += [4, 5, 6]

print(A)
print(B)

"""Usando sÃ³lo **.copy()** no alcanza para que se copien las estructuras internas. Esto se llama una copia *superficial*, solamente la capa "externa" es la que se copia."""

A = [[1,2,3], [4,5,6], [7,8,9]]
B = A.copy()
B[0][0] = 999
B += [10, 11, 12]

print(A)
print(B)

"""Con **copy.deepcopy()** realizamos una copia real *en profundidad*:"""

import copy

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
B = copy.deepcopy(A)
B[0][0] = 999
B += [10, 11, 12]

# La lista A se mantiene intacta
print(A)
print(B)

"""#### [random](https://docs.python.org/3/library/random.html)

* *GeneraciÃ³n aleatoria de nÃºmeros*
"""

import random

# Elige entre elementos de una lista
opciones = ['Manzanas', 'Bananas', 'Naranjas']
print( random.choice(opciones) )

# NÃºmero entero entre 10 y 20
print( random.randint( 10, 20 ) )

# NÃºmero real que pertenece al intervalo [0, 1)
print( random.random() )

# NÃºmero real con distribuciÃ³n gaussiana de media 0 y desvÃ­o estÃ¡ndar 1
print( random.gauss(0, 1) )

"""#### [time](https://docs.python.org/3/library/time.html)

* *Funciones relacionadas al manejo del tiempo*
"""

import time

print(1)
time.sleep(1)
print(2)
time.sleep(1)
print(3)
time.sleep(1)
print(4)
time.sleep(1)
print(5)
time.sleep(1)
print('AdiÃ³s!')

"""#### [datetime](https://docs.python.org/3/library/datetime.html)

* *ManipulaciÃ³n de fechas y horarios*
"""

from datetime import datetime, timedelta

now = datetime.now()
print(now)
print(now.time())

new_time = datetime(2010, 2, 6, 10, 8, 20, 0)
print(new_time)
new_time += timedelta(days=31, hours=1)
print(new_time)

"""#### [csv](https://docs.python.org/3/library/csv.html)

* *ManipulaciÃ³n de archivos CSV*
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/datos.csv"

import csv

csvfile = open('datos.csv')
lector = csv.reader(csvfile)
for fila in lector:
  print(fila)

"""#### [NumPy](https://numpy.org/)
* *CÃ¡lculo algebraico*

NumPy permite crear vectores y matrices multidimensionales, junto con una gran colecciÃ³n de funciones matemÃ¡ticas de alto nivel para operar con ellos de forma muy eficiente.
"""

import numpy as np

A = np.array(([1, 2, 3], [4, 5, 6]))
B = np.array(([1, 2], [4, 5], [7, 8]))
C = np.dot(A, B)

print('A =')
print(A)
print()
print('B =')
print(B)
print()
print('A.B =')
print(C)

"""#### [Matplotlib](https://matplotlib.org)
* *VisualizaciÃ³n de datos*

Matplotlib permite representar datos de forma grÃ¡fica y cuenta con una gran cantidad de tipos y formatos de grÃ¡ficos para utilizar. Permite crear visualizaciones estÃ¡ticas, animadas Ã³ interactivas.
"""

# Ejemplo provisto por matplotlib para darse una idea del uso de esta herramienta
# No es necesario entender cÃ³mo funciona

import matplotlib
import numpy as np
import matplotlib.pyplot as plt

# example data
mu = 100  # mean of distribution
sigma = 15  # standard deviation of distribution
x = mu + sigma * np.random.randn(437)

num_bins = 50

fig, ax = plt.subplots(figsize=(10, 5))

# the histogram of the data
n, bins, patches = ax.hist(x, num_bins, density=True)

# add a 'best fit' line
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) *
     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
ax.plot(bins, y, 'r--')
ax.set_xlabel('Value')
ax.set_ylabel('Probability density')
ax.set_title(r'Histogram of random samples: $\mu=100$, $\sigma=15$')

# Tweak spacing to prevent clipping of ylabel
fig.tight_layout()
plt.show()

"""## Para seguir aprendiendo...

Como contenido extra, sÃ³lo para aquellos interesados en seguir investigando contenido relacionado, incluÃ­mos 2 Anexos al final de la clase que se relacionan con el formato *JSON*.

AdemÃ¡s, al final de la clase podrÃ¡n encontrar a modo de anexo, fragmentos de transmisiones en vivo de aÃ±os anteriores que podrÃ­an ser de su interÃ©s.

La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

# **Â¿CÃ³mo seguir despuÃ©s del curso?**

En este curso introductorio aprendimos las bases del lenguaje Python y de a poco comenzamos a realizar aplicaciones prÃ¡cticas. En IEEE-ITBA ofrecemos un curso mÃ¡s avanzado en el cual se explica en profundidad la manipulaciÃ³n de archivos de hojas de datos (Excel) y la visualizaciÃ³n de datos mediante Matplotlib. Nuestro objetivo es que puedan aprender lo suficiente para crear aplicaciones simples, pero de gran utilidad. Esperamos que sientan que ya son programadores de Python y que puedan terminar el curso con buenas primeras experiencias y ganas de realizar proyectos ambiciosos. No estÃ¡ de mÃ¡s recordar que en este mundo el conocimiento no lo es todo, se aprende sobre la marcha y no hay que temer a emprender proyectos que utilicen herramientas novedosas las cuales hasta ahora nunca utilizaron. Si lograron terminar este curso es que supieron adaptarse a nuevos desafÃ­os y no hay razÃ³n por la cual no puedan enfrentarse a lo que se propongan.

Ya que el universo de cosas para aprender es infinito, y que este curso es introductorio, nos parece oportuno comentar algunas de las cosas que le puede interesar a todo aquel que quiera seguir especializÃ¡ndose en este lenguaje en el futuro:

- Clases y ProgramaciÃ³n Orientada a Objetos:
 - [A Byte of Python](https://python.swaroopch.com/oop.html)
 - [RealPython](https://realpython.com/python3-object-oriented-programming/)
 - [Docs Python](https://docs.python.org/3/tutorial/classes.html)
 - [Video de MatÃ­as Bergerman](https://youtu.be/ZB9brIzJU7c)
- Excepciones: instrucciones `try`, `except`, `finally`, `with`:
 - [A Byte Of Python](https://python.swaroopch.com/exceptions.html)
 - [RealPython](https://realpython.com/python-exceptions/)
 - [Docs Python](https://docs.python.org/3/tutorial/errors.html)
- Funciones Lambda:
 - [RealPython](https://realpython.com/python-lambda/)
 - [W3Schools](https://www.w3schools.com/python/python_lambda.asp)
 - [Video de MatÃ­as Bergerman](https://youtu.be/4jy4ADH_7i0)

\

## Propuestas de proyectos
En el [Ãºltimo capÃ­tulo](https://python.swaroopch.com/what_next.html) del libro A Byte of Python se ofrecen muchos recursos que pueden resultarles muy interesantes: propuestas de proyectos, videos para ver, consejos, tutoriales, recursos para creaciÃ³n de pÃ¡ginas web e interfaces grÃ¡ficas, y algunas cosas mÃ¡s.

Hacer un proyecto de cierta complejidad definitivamente serÃ¡ un desafÃ­o, les proponemos intentar dividir su proyecto en partes, sub-tareas, y resolver cada problema por separado antes de unir todas las partes. TambiÃ©n es muy recomendable buscar informaciÃ³n e investigar acerca de los temas que no conocen, ademÃ¡s de pedir ayuda o preguntar en foros cuando lo necesitan, Â¡nadie programa solo!

Les proponemos a continuaciÃ³n algunas otras ideas de proyectos que se nos ocurrieron por si alguno les llama la atenciÃ³n, que podrÃ­an hacer con los conocimientos adquiridos en el curso e investigando algunas herramientas nuevas:

- **Pomodoro Timer**

  El objetivo del proyecto es crear una aplicaciÃ³n para utilizar la [tÃ©cnica pomodoro](https://es.wikipedia.org/wiki/T%C3%A9cnica_Pomodoro) de administraciÃ³n de tiempo. El programa debe poder cronometrar bloques de 25 minutos de concentraciÃ³n intercalados con 5 minutos de descanso, si desean estos tiempos podrÃ­an ser customizables. Adicionalmente, podrÃ­an hacer una interfaz grÃ¡fica para la aplicaciÃ³n. Una alternativa para esto es la librerÃ­a [tkinter](https://docs.python.org/3/library/tkinter.html), para comenzar a usarla les recomendamos empezar por un tutorial como el de [RealPython](https://realpython.com/python-gui-tkinter/).

- **Web Scrapping**

  El objetivo del proyecto es obtener informaciÃ³n de una pÃ¡gina en forma sistemÃ¡tica, especialmente cuando esta pÃ¡gina no provee una forma fÃ¡cil de obtener los datos en forma escalable. Por ejemplo, se pueden analizar los precios/reviews/preguntas de cientos de miles de productos en una pÃ¡gina de e-commerce en forma automÃ¡tica con Python. Para esto les recomendamos investigar acerca de la librerÃ­a [Selenium](https://selenium-python.readthedocs.io/) y seguir un tutorial la primera vez que la usan.

- **CÃ¡lculo del factor de transmisiÃ³n del coronavirus**

  El objetivo es automÃ¡ticamente descargar los datos actualizados de casos de coronavirus diarios en el paÃ­s (usando por ejemplo `wget`), abrir el archivo con la librerÃ­a `csv` o alguna similar, y calcular parÃ¡metros de interÃ©s como el factor de transmisiÃ³n R, o la tasa de duplicaciÃ³n de casos. Pueden usar una pÃ¡gina como [Our World In Data](https://covid.ourworldindata.org/data/owid-covid-data.csv) para obtener la informaciÃ³n.

- **Bot de Instagram**

  La idea del proyecto es automatizar actividades realizadas en instagram mediante una aplicaciÃ³n de Python. Para esto les recomendamos investigar la librerÃ­a [InstaPy](https://instapy.org/). TambiÃ©n hay una introducciÃ³n interesante a la librerÃ­a hecha por [RealPython](https://realpython.com/instagram-bot-python-instapy/).

- **Filtro de imÃ¡genes personalizado**

  Utilizar una librerÃ­a de manipulaciÃ³n de imÃ¡genes para aplicar un filtro especial a las imagenes indicadas, o todas las imagenes dentro de cierta carpeta. Les sugerimos investigar acerca de la librerÃ­a [Pillow](https://python-pillow.org/). El filtro podrÃ­a ser un difuminado, blanco y negro, agregar un watermark o ser tan sofisticado como quieran. TambiÃ©n podrÃ­an darle la opciÃ³n al usuario de elegir el filtro que quiere aplicar dentro de un listado.

## **Casos de aplicaciÃ³n**

Como conclusiÃ³n, les mostramos a continuaciÃ³n algunos ejemplos de aplicaciÃ³n de **Python** realizados por miembros del equipo organizador, por si les llegan a interesar:

### **ResoluciÃ³n de EDOs - Ejercicio de Reactores I**
*Ariel Nowik, Joaquin Mestanza, Tomas Wierzba*

Resolvemos una ecuaciÃ³n diferencial de una materia de QuÃ­mica mediante un script de Python en lugar de la manera "tradicional" con un excel. Muchas veces utilizar un script es mÃ¡s prÃ¡ctico y versÃ¡til ya que se puede integrar con otras funcionalidades del lenguaje.

([CÃ³digo aqui](https://github.com/jmestanza/ideas/tree/master/QuimicaEdos)) 


### **Web scrapper - pÃ¡gina web del itba**
*Ariel Nowik*

Un scrapper es un script capaz de extraer informaciÃ³n y escribir informaciÃ³n en una pÃ¡gina web (es un bot). Este cÃ³digo de python analiza la pÃ¡gina del itba para conseguir informaciÃ³n de las distintas materias de forma automÃ¡tica.

([CÃ³digo aqui](https://github.com/elgrandt/CalificaProfesores-Utils/blob/master/scrapping/itba.py))

### **CalcuPy**
*MatÃ­as Bergerman*

Una simple calculadora por consola programada en Python. Implementa clases y una [estructura de Ã¡rbol](https://es.wikipedia.org/wiki/%C3%81rbol_(inform%C3%A1tica)) para representar expresiones matemÃ¡ticas.

([CÃ³digo aqui](https://github.com/mbergerman/CalcuPy/blob/main/calcu.py))

### **Book Selector**
*Ignacio Vidaurreta*

Este script elige un libro al azar para que el usuario lea uno nuevo.

([CÃ³digo aqui](https://github.com/ignacioVidaurreta/bookSelector))

### **Piedra papel o tijera**
*Ignacio Vidaurreta*

Este script es un juego (por consola) de piedra papel o tijera.

([CÃ³digo aqui](https://github.com/ignacioVidaurreta/rockPaperScissors/blob/master/rps.py))

### **MÃ©todo de los Elementos Finitos**
*Patricio Whittingslow*

Calcula deformaciones para una estructura reticulada con cargas.

([CÃ³digo aqui](https://colab.research.google.com/drive/12ZVTs7eIwoIAS_IIi68O-YoDzCfQ629u)).

### **Herramienta para graficar funciones de transferencia**
*MatÃ­as Bergerman, Pedro Carranza VÃ©lez, Pablo GonzÃ¡lez*

Interfaz grÃ¡fica hecha con Qt para comparar curvas de transferencia medidas, simuladas y calculadas de forma teÃ³rica.

([CÃ³digo aqui](https://github.com/pabgonzalez/Plot_Tool))

# $\color{\green}\blacktriangleright$ DesafÃ­o a Entregar: Las Elecciones

*Los desafÃ­os se entregan mediante [esta pÃ¡gina](https://www.hackerrank.com/2022-1c-curso-introductorio-de-python) de HackerRank. Pueden ver un instructivo acerca del uso de la plataforma en [este link](https://youtu.be/pqYSwABnS_k).*

Realizar un programa en el cual se decida el ganador de unas **elecciones**.

El programa primero recibe un nÃºmero $N$, la cantidad de votos totales que se realizaron. Luego recibe $N$ votos en formato string, cada uno consiste en el nombre del candidato seleccionado. El programa debe calcular el ganador e imprimir su nombre. Para este ejemplo se asume que no hay empates. Los nombres y la cantidad de candidatos es desconocida.

**Ejemplo:**

- *Input:*

 ```python
12
Mickey
Donald
Mickey
Minnie
Mickey
Goofy
Daisy
Goofy
Goofy
Minnie
Goofy
Donald
```

- *Output:*

 ```
 Goofy
 ```
 El resultado es Goofy ya que este recibe 4 votos, la cual es la mayor cantidad de votos.
"""



"""# EjercitaciÃ³n integradora $\newcommand{\dif}{\bigstar}$$\newcommand{\facil}{\color{\green}{\dif}}$ $\newcommand{\pieceofcake}{\color{\cyan}{\dif}}$$\newcommand{\medio}{\color{\yellow}{\dif\dif}}$$\newcommand{\media}{\medio}$$\newcommand{\normal}{\medio}$  $\newcommand{\dificil}{\color{\orange}{\dif\dif\dif}}$ $\newcommand{\imposible}{\color{\red}{\dif\dif\dif\dif}}$
$\newcommand{\tarc}{\large\frown}$
$\newcommand{\arc}[1]{\stackrel{\tarc}{#1}}$
<head>
<style type="text/css">
  .img{ 
    display: block;
    margin-left:auto;
    margin-right:auto;
  }
  </style>
  </head>

A continuaciÃ³n les proponemos resolver algunos ejercicios integradores. Este contenido servirÃ¡ para poder practicar lo aprendido y de a poco acercarse a lo que podrÃ­a ser una aplicaciÃ³n real. No se preocupen si no llegan a terminar todos, o si les cuestan mÃ¡s que los desafÃ­os de la clase. Es cuestiÃ³n de tomarse el tiempo de leer, pensar, y probar diferentes ideas hasta que encuentren una posible soluciÃ³n al problema.

Luego de una semana les enviaremos una copia de las soluciones que se nos ocurrieron a nosotros para resolver estos problemas y poder comparar en caso de que lo deseen.

### $\facil$ El ABC de Python

*AclaraciÃ³n: Este desafÃ­o es inventado, es posible que haya errores fÃ¡cticos en cuanto a los alfabetos reales.*

Encontramos una piedra antigua en una plaza de Buenos Aires cuyas inscripciones nos ayudan a decifrar nuevos alfabetos. Gracias a estas inscripciones descubrimos que las letras del [alfabeto latino arcaico](https://es.wikipedia.org/wiki/Alfabeto_latino#Alfabeto_latino_arcaico) tienen una correspondencia con el [alfabeto latino](https://es.wikipedia.org/wiki/Alfabeto_latino) y vamos a crear un programa que nos ayude a traducir palabras de un alfabeto a otro.

Crear una funciÃ³n que recibe un *string*, transforma todos los caracteres del *alfabeto latino arcaico*  en caracteres modernos, no modifica el resto de los caracteres (signos de puntuacion, espacios, letras, nÃºmeros, etc.) y devuelve el resultado con *return*.

**Ejemplos:**

`traducir( "ğŒ€ğŒ‹ğŒ…ğŒ€ğŒğŒ„ğŒ•ğŒ" )` â†’ `"ALFABETO"`

`traducir( "Â¡ğŒğŒ„ğŒ“ğŒƒğŒ‰!" )` â†’ `"Â¡PERDI!"`

`traducir( "Â¿ğŒ”ğŒ‰ ğŒ ğŒğŒ? ğŒŒğŒŒğŒŒ... ğŒ”ğŒ‰." )` â†’ `"Â¿SI O NO? MMM... SI."`

**Correspondencia entre alfabetos:**
```python
Arcaico : Moderno
'ğŒ€' : 'A',
'ğŒ' : 'B',
'ğŒ‚' : 'C',
'ğŒƒ' : 'D',
'ğŒ„' : 'E',
'ğŒ…' : 'F',
'ğŒ†' : 'Z',
'ğŒ‡' : 'H',
'ğŒ‰' : 'I',
'ğŒŠ' : 'K',
'ğŒ‹' : 'L',
'ğŒŒ' : 'M',
'ğŒ' : 'N',
'ğŒ' : 'O',
'ğŒ' : 'P',
'ğŒ’' : 'Q',
'ğŒ“' : 'R',
'ğŒ”' : 'S',
'ğŒ•' : 'T',
'ğŒ–' : 'V',
'ğŒ—' : 'X'
```
"""

arcaico = {'ğŒ€' : 'A', 'ğŒ' : 'B', 'ğŒ‚' : 'C', 'ğŒƒ' : 'D', 'ğŒ„' : 'E', 'ğŒ…' : 'F',
           'ğŒ†' : 'Z', 'ğŒ‡' : 'H', 'ğŒ‰' : 'I', 'ğŒŠ' : 'K', 'ğŒ‹' : 'L', 'ğŒŒ' : 'M',
           'ğŒ' : 'N', 'ğŒ' : 'O', 'ğŒ' : 'P', 'ğŒ’' : 'Q', 'ğŒ“' : 'R', 'ğŒ”' : 'S',
           'ğŒ•' : 'T', 'ğŒ–' : 'V', 'ğŒ—' : 'X' }

def traducir(texto):
  resultado = ""
  for letra in texto:
    if letra in arcaico:
      resultado += arcaico[letra]
    else:
      resultado += letra
  return resultado

print(traducir("ğŒ€ğŒ‹ğŒ…ğŒ€ğŒğŒ„ğŒ•ğŒ"))
print(traducir("Â¡ğŒğŒ„ğŒ“ğŒƒğŒ‰!"))
print(traducir("Â¿ğŒ”ğŒ‰ ğŒ ğŒğŒ? ğŒŒğŒŒğŒŒ... ğŒ”ğŒ‰."))
print(traducir("ğŒ€ğŒ‹ğŒ…ğŒ€ğŒğŒ„ğŒ•ğŒ, Â¡ğŒğŒ„ğŒ“ğŒƒğŒ‰!, Â¿ğŒ”ğŒ‰ ğŒ ğŒğŒ? ğŒŒğŒŒğŒŒ... ğŒ”ğŒ‰."))

"""###$\facil$ AnÃ¡lisis estadÃ­stico de fallas en lotes de producciÃ³n II

Adaptar la soluciÃ³n al ejercicio integrador de la clase pasada para utilizar librerÃ­as en lugar de programar todo de forma manual. Pueden usar la librerÃ­a **csv** para importar el archivo, y las librerÃ­as **numpy** o **scipy** para calcular la media, varianza, moda y mediana.

**Tip:** Pueden investigar el uso de estos mÃ©todos en la documentaciÃ³n de las librerÃ­as:

* Media: [numpy.mean](https://numpy.org/doc/stable/reference/generated/numpy.mean.html)
* Varianza: [numpy.var](https://numpy.org/doc/stable/reference/generated/numpy.var.html)
* Moda: [scipy.stats.mode](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mode.html)
* Mediana: [numpy.median](https://numpy.org/doc/stable/reference/generated/numpy.median.html)

A continuaciÃ³n pueden ver una copia de la consigna:

Una planta de producciÃ³n de botellas plÃ¡sticas fabrica 1000 lotes de botellas por dÃ­a. Debido al proceso de fabricaciÃ³n algunas de las botellas salen falladas. Estos fallos son detectados automÃ¡ticamente durante el proceso de control de calidad y se cargan en una base de datos que registra la cantidad de productos fallados por cada lote. El departamento de control de calidad sospecha que la cantidad de fallos por lote sigue una distribuciÃ³n de *Poisson*, pero todavÃ­a no conocen la media y la varianza.

Se pide importar los datos de los Ãºltimos 30 dÃ­as (en total son 30000 datos) y calcular la *media*, la *varianza*, la *moda* y la *mediana* de la distribuciÃ³n de datos medidos. Los datos se encuentran en el archivo *ControlCalidadBotellas.csv* bajo la columna *Fallas*.

**Definiciones:**
- **Media:** El valor promedio:

  $\mu=\frac{X_1+X_2+X_3+\cdots+X_n}{n}$

- **Varianza:** El promedio de las distancias al cuadrado entre cada valor y la media:

  $\sigma^2=\frac{(X_1-\mu)^2+(X_2-\mu)^2+\cdots+(X_n-\mu)^2}{n}$

- **Moda:** El valor que ocurre con mayor frecuencia.

- **Mediana:** El valor que cumple la propiedad que la mitad de las veces el valor medido es menor a la mediana y la otra mitad de las veces es mayor.

Si las sospechas acerca de la distribuciÃ³n fueran correctas, entonces de acuerdo a las propiedades de la distribuciÃ³n de Poisson la media y la varianza deberÃ­an ser iguales. AdemÃ¡s la moda serÃ­a $\lceil{\mu}\rceil-1$. Â¿Esta sospecha les parece acertada?
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/ControlCalidadBotellas.csv"

# Instalar las librerÃ­as en el entorno de Colab
! pip install numpy
! pip install scipy

import csv
import numpy
from scipy import stats

# Lectura del archivo
csvfile = open("ControlCalidadBotellas.csv")
lector = csv.reader(csvfile)

# Armo una lista con laa cantidad de fallas por dÃ­a
fallas = []
for fila in lector:
  if fila[1] != "Fallas":
    fallas.append( int(fila[1]) )

# CÃ¡lculo de las diferentes mÃ©tricas
media = numpy.mean(fallas)
var = numpy.var(fallas)
moda, count = stats.mode(fallas)
mediana = numpy.median(fallas)

print("La media es:", media)
print("La varianza es:", var)
print("La moda es:", moda[0])
print("La mediana es:", mediana)

"""### $\facil$ DiccionarioÂ²
Se recibieron distintos postulantes para un empleo de traductor. Crear un **diccionario** en el cual la *clave* de cada elemento sea el nombre de un candidato y el *contenido* sea un **diccionario** de los idiomas que aprendiÃ³. Para armar el diccionario de idiomas de cada candidato, los elementos deben tener como *clave* el nombre del idioma y como *contenido* el valor True o False para los siguientes idiomas: EspaÃ±ol, InglÃ©s, Chino, Frances, Italiano.

Ejemplo del **diccionario** de idiomas:

```python
{"EspaÃ±ol":True, "InglÃ©s":True, "Chino":False, "Frances":False, "Italiano":True}
```

Inventar valores para 5 candidatos.

El usuario luego debe poder ingresar el nombre de un idioma y el programa deberÃ¡ mostrar en pantalla el nombre de aquellos candidatos que aprendieron ese idioma.
"""

postulantes = {
    "Juan" : {"EspaÃ±ol":True, "Ingles":True, "Chino":False, 
              "Frances":False, "Italiano":True}, 
    "Pablo" : {"EspaÃ±ol":False, "Ingles":True, "Chino":True, 
               "Frances":False, "Italiano":True}, 
    "Carlos" : {"EspaÃ±ol":True, "Ingles":False, "Chino":False, 
                "Frances":True, "Italiano":True},
    "Ana" : {"EspaÃ±ol":True, "Ingles":True, "Chino":True, 
             "Frances":False, "Italiano":True},
    "Maria" : {"EspaÃ±ol":False, "Ingles":True, "Chino":False, 
               "Frances":False, "Italiano":True}
}

idioma = input("Ingrese un idioma: ")

for nombre, dicParticular in postulantes.items():
    if idioma in dicParticular and dicParticular[idioma] == True:
        print(nombre, 'habla', idioma)

"""###$\normal$  Une y triunfarÃ¡s (continuaciÃ³n de DiccionarioÂ²)
Se recibieron distintos postulantes para un empleo de traductor. Crear un **diccionario** en el cuÃ¡l la *key* de cada elemento sea el nombre de un candidato y el *contenido* sea un **set** con los idiomas que aprendiÃ³.
Inventar sets para 5 candidatos.

Ejemplo del **set** de idiomas:

```python
{"EspaÃ±ol", "InglÃ©s", "PortuguÃ©s", "Italiano"}
```

- Mostrar en pantalla los idiomas que todos los candidatos aprendieron.
- Mostrar en pantalla todos los candidatos que aprendieron por lo menos EspaÃ±ol e InglÃ©s.

"""

postulantes = {
    "Juan" : {"EspaÃ±ol", "Ingles", "Italiano"} , 
    "Pablo" : {"Ingles", "Chino", "Italiano"}, 
    "Carlos" : {"EspaÃ±ol", "Frances", "Italiano"},
    "Ana" : {"EspaÃ±ol", "Ingles", "Chino", "Italiano"},
    "Maria" : {"Ingles", "Italiano"}
}

# Creamos un set con todos los idiomas
todos = {"EspaÃ±ol", "Ingles", "Chino", "Frances", "Italiano"}

for p in postulantes:
  todos &= postulantes[p] # Es lo mismo que: todos = todos & postulantes[p]

print("Todos los candidatos aprendieron este(os) idioma(s):")
for i in todos:
  print(i)

# Creamos un set vacio
esp_ing = set() 
for p in postulantes:
  if "EspaÃ±ol" in postulantes[p] and "Ingles" in postulantes[p]:  
    # QuÃ© postulantes que saben ingles y espaÃ±ol
    esp_ing.add(p)

print("Los candidatos que aprendieron al menos EspaÃ±ol e InglÃ©s:")
for i in esp_ing:
  print(i)

"""### $\medio$ AnÃ¡lisis de idiomas

Importar el archivo **noticia.txt**
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/noticia.txt"

"""Calcular la [frecuencia de apariciÃ³n de letras](https://es.wikipedia.org/wiki/Frecuencia_de_aparici%C3%B3n_de_letras). Compararla con la frecuencia de letras caracterÃ­stica del idioma EspaÃ±ol (en el articulo de wikipedia pueden encontrarla). Â¿Existe alguna relaciÃ³n?

**Tips:**
- Pasar todas las letras a mayÃºsculas o todas a  minÃºsculas.
- Reemplazar las vocales con tilde por la misma vocal sin tilde antes de realizar el conteo.
- Descartar los nÃºmeros y caracteres no deseados. El mÃ©todo `.isalpha()` les puede ser de utilidad para este propÃ³sito.
"""

def segundo_valor(x):
  return x[1]

file = open("noticia.txt") # cargamos el archivo a la memoria
contenido = file.readlines() # calculamos todas las lineas

tildes = {'Ã¡':'a', 'Ã©':'e', 'Ã­':'i', 'Ã³':'o', 'Ãº':'u'}

total = 0
ocurrencias = {}
for renglon in contenido:
  renglon_lower = renglon.lower() # pasamos a minÃºscula el archivo.
  for letra in renglon_lower:
    # Si la letra tiene tilde, la remplazo por su versiÃ³n sin tilde.
    if letra in tildes:     
      letra = tildes[letra]
    
    if letra.isalpha():     
      # Si la letra es alfanumerica, la agrego a la lista de ocurrencias.
      # Info get(): https://www.w3schools.com/python/ref_dictionary_get.asp
      ocurrencias[letra] = ocurrencias.get(letra, 0) + 1  
      total += 1

items = ocurrencias.items()

# Info Sorted: https://www.programiz.com/python-programming/methods/built-in/sorted
# Ordenamos las ocurrencias de mayor a menor.
lista = sorted(items, key = segundo_valor, reverse = True) 

for k,v in lista:
  print("{} aparece {} veces: {:0.3f} %".format(k, v, v/total * 100))

"""### $\dificil$ Menta y Dulce de leche

**IntroducciÃ³n:**

*Una de las muchas ventajas de los sets y los diccionarios es que permiten averiguar si contienen cierto elemento con gran velocidad, sin importar la cantidad de elementos que almacenan (esto se debe a que internamente utilizan una [funciÃ³n hash](https://es.wikipedia.org/wiki/Funci%C3%B3n_hash)). Acceder al valor asociado a cierta clave en un diccionario tambiÃ©n es una operaciÃ³n muy veloz.*

*En comparaciÃ³n, verificar si un elemento se encuentra dentro de una lista es lento, ya que el tiempo necesario es proporcional a la cantidad de elementos en la lista y para listas muy grandes con miles, millones o billones de elementos (como puede suceder en una base de datos) esto puede ser un problema importante. Sin embargo, una vez que se conoce el Ã­ndice del elemento, acceder al elemento es una operaciÃ³n tan rÃ¡pida como en un diccionario.*

**Problema:**

Volviendo de hacer las compras en el supermercado, pasÃ¡s cerca de una heladerÃ­a y decidÃ­s comprar helado para tus hermanos, los cuales son amantes de la menta granizada y del dulce de leche con nuez. El negocio ofrece helado en todo tipo de formato, desde mini-cucuruchos hasta potes de 1 kilo, y cada formato cuesta cierta cantidad de dinero. DecidÃ­s gastar exactamente todo el dinero que te queda luego de haber ido al supermercado, de forma tal que no sobre ni falte.

Programar una funciÃ³n que recibe una lista con los precios de los distintos formatos en que se vende el helado, y ademÃ¡s reciba la cantidad de dinero disponible para gastar. La funciÃ³n debe encontrar la manera de comprar cierto formato de helado sabor menta, y cierto formato sabor dulce de leche, de manera de gastar la totalidad del dinero disponible. En consecuencia, la cantidad de formatos seleccionados debe ser exactamente 2. EstÃ¡ permitido seleccionar el mismo formato para ambos sabores de helado. La funciÃ³n debe devolver con *return* una lista de 2 elementos, los cuales serÃ¡n los precios de los formatos de helado seleccionados. En caso de no existir una combinaciÃ³n que satisface los requisitos se debe devolver ``[-1, -1]``.

**Tips:**
 - Al usar un set o un diccionario como estructura de datos pueden mejorar la velocidad con la que el programa analiza si cierto elemento se encuentra dentro de los datos. La operaciÃ³n ``mi_set = set( mi_lista )`` puede serles de utilidad para este propÃ³sito.

**Ejemplos:**

`buscar_precios( [1, 2, 3, 4, 5] , 8)` â†’ `[3, 5]`

`buscar_precios( [7, 4, 2, 6, 7, 7] , 4)` â†’ `[2, 2]`

`buscar_precios( [4, 3, 7, 5] , 5)` â†’ `[-1, -1]`

\

$\dificil$ *Challenge*: Modificar la funciÃ³n para que el resultado sea un sÃ³lo nÃºmero: La cantidad de maneras diferentes de conseguir el objetivo (si dos formatos tienen el mismo precio, igualmente califican como formatos diferentes).
"""

def buscar_precios(lista_precios, dinero):
  # Convertir la lista en un set
  set_precios = set(lista_precios)

  # Iterar por todos los precios en el set
  # Analizar si el dinero restante se encuentra en el set
  for p in set_precios:
    restante = dinero - p
    if restante in set_precios:
      return [p, restante]

  # En caso de no lograr una combinaciÃ³n, devolver [-1, -1]
  return [-1, -1]

print(buscar_precios( [1, 2, 3, 4, 5] , 8))
print(buscar_precios( [7, 4, 2, 6, 7, 7] , 4))
print(buscar_precios( [4, 3, 7, 5] , 5))

"""### $\dificil$ Dr. Chaos, el malevolo semiÃ³tico

"Chaos es caos en inglÃ©s" te dirÃ­a Dr. Chaos, charlando con una taza de tÃ© Chai en la mano. En verdad no es tÃ¡n malo como su nombre lo hace aparentar... si es que tenÃ©s un buen manejo de los idiomas.

Dr. Chaos esta armando un diccionario. Este diccionario tiene la particularidad de no tener definiciones; el diccionario de Dr. Chaos define *una palabra como otra*. Dr. Chaos quiere comenzar a traducir la literatura de todo el mundo usando el diccionario y ha venido a ti, el *Number One* programador de Python. 

**Objetivo:** Cambiar las palabras de una oraciÃ³n usando el diccionario de Dr. Chaos e imprimir la nueva oraciÃ³n en el lenguaje unificado.

**Ejemplos:**

 - Input 1:
 ```python 
diccionario = {"hola":"ä½ å¥½","como":"how","estÃ¡s":"estÃ¡is"}
oracion = "hola, como estÃ¡s?"
```
  Output 1:
```python 
"ä½ å¥½, how estÃ¡is?"
```

 - Input 2:
 ```python 
diccionario = {"ve":"regards","bien":"bom","se":"it"}
oracion = "se ve bien!"
```

 Output 2:
```python 
"it regards bom!"
```


**Tips:** 

* Los sÃ­mbolos de interrogaciÃ³n, exclamaciÃ³n, los puntos y comas no forman parte de las palabras y no se deben modificar.
 
* Suponer que las letras son todas minÃºsculas.

"""

# SoluciÃ³n 1

espanolToChaos = {"ve":"regards", "bien":"bom", "se":"it"}
oracion = "se ve bien!"
whitespace = [" ", ".", ",", "!", "?"]

resultado = ""
palabra = ""
for i in range(0, len(oracion)):
    letra = oracion[i]
    if letra in whitespace: # reviso si la letra es una espacio en blanco
        if palabra != "":
            # traducir la palabra que tengo hasta ahora y agregarla
            resultado = resultado+espanolToChaos[palabra] 
    
        resultado = resultado+letra # agrego el espacio a la palabra nueva
        palabra = ""
    else:
        palabra = palabra + letra
        
print(resultado)

"""###$\imposible$ Quiero Retruco
El [Truco](https://es.wikipedia.org/wiki/Truco_argentino) es un juego de cartas muy popular en Argentina. Se suele jugar con naipes espaÃ±oles de 40 cartas, las cuales tienen 4 palos (basto, oro, espada y copa) y 10 nÃºmeros (1, 2, 3, 4, 5, 6, 7, 10, 11 y 12).
Si bien en esta ocasiÃ³n no vamos a programar un juego de truco, sÃ­ vamos a resolver uno de los problemas mÃ¡s usuales que surgen cuando jugamos, el cual es definir quÃ© carta gana y quÃ© carta pierde cuando hay un duelo entre dos cartas. 

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/truco_jerarquia.png" height=300 alt ="Esquema de hierarquia de cartas para el juego truco argentino" title="Un palo le gana a 7 espadas y ambos pierden ante una espada envainada? What?">

En la imagen podemos observar el orden de importancia de las cartas de izquierda a derecha. El 1 de espada es la mÃ¡s importante (y por lo tanto **siempre** gana) mientras que los 4s son las cartas de menor importancia (casi siempre pierden). Las cartas en la misma columna empatan si se enfrentan.

- Programar una funciÃ³n con dos inputs tipo string **carta A** y **carta B** que retorne la carta ganadora (tipo string), o "empate" en caso de que lo haya. Ejemplos de como deberÃ­a funcionar

 ```
   dueloDeCartas("1 de espada", "1 de basto")
   >>> 1 de espada
   dueloDeCartas("7 de oro", "5 de oro")
   >>> 7 de oro
   dueloDeCartas("11 de copa", "11 de espada")
   >>> empate
```

 **Pista** (el texto a continuaciÃ³n es de color blanco, seleccionar para poder verlo): <font color="white"> Usar un diccionario donde la **clave** sea el nombre de la carta, y su **contenido** su importancia (un tipo **int**). Aprovechen la instrucciÃ³n *for* para evitar tener que cargar todas las cartas una por una.
</font>

- A veces se suele jugar al truco con mÃ¡s de dos jugadores. PodrÃ­a ocurrir duelos en los que participan $n$ cartas. Programar una funciÃ³n cuyo input sea una lista de strings con todas las cartas y retorne la ganadora. (En caso de empate que retorne alguna de las ganadoras, o una lista con las ganadoras).
Ejemplos de como podrÃ­a funcionar:
```
   dueloDeCartas(["7 de basto","7 de espada","12 de espada", "4 de espada"])
   >>> "7 de espada"
   dueloDeCartas(["4 de espada","7 de basto","7 de copa", "5 de copa"]) #tambiÃ©n podrÃ­a haber dado 7 de basto 
   >>> "7 de copa"
```
"""

# SoluciÃ³n 1: diccionario

""" 
Antes de hacer la funcion dueloDeCartas, creamos el diccionario que leerÃ¡ 
para saber que carta gana 
"""

valorCarta = dict() 

# casos especiales: esto no lo puedo hacer con un for
valorCarta["1 de espada"] = 14    
valorCarta["1 de basto"] = 13     
valorCarta["7 de espada"] = 12
valorCarta["7 de oro"] = 11

# el resto de los valores son de 10 para abajo
valor = 10
for x in [3, 2, 1, 12, 11, 10, 7, 6, 5, 4]: 
    # itero por los numeros de las cartas, de la mas a la menos poderosa
    if x == 1: # con este if elijo que palos de este numero guardo
        palos = ["oro","copa"] 
    elif x == 7:
        palos = ["basto", "copa"]
    else: 
        palos = ["oro", "copa", "basto", "espada"]

    # para todos los palos que elegÃ­, guardo la carta con el mismo valor
    for palo in palos:
        valorCarta[str(x) + " de " + palo] = valor
        
    valor -= 1 # la carta que viene es menos poderosa

def dueloDeCartas(cartaA, cartaB):
    # usamos el diccionario que creamos para saber el valor de las cartas
    # que nos pasan
    if valorCarta[cartaA] > valorCarta[cartaB]:
        return cartaA
    elif valorCarta[cartaA] < valorCarta[cartaB]:
        return cartaB
    else:
        return "empate"
    
    
# verificamos que la funcion ande correctamente
print(dueloDeCartas("7 de basto","1 de basto"))
print(dueloDeCartas("1 de copa", "1 de oro"))
print(dueloDeCartas("7 de copa","3 de copa"))

"""#Anexos
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

## Anexo A: JSON

*JSON* es un formato de representaciÃ³n de informaciÃ³n estructurada que es de gran utilidad. Su sintaxis es simple y fÃ¡cil de leer a simple vista, ademÃ¡s de que tiene una gran similitud con la sintaxis propia de Python. En la [pÃ¡gina web de *JSON*](https://www.json.org/json-es.html) hay explicaciones bastante claras acerca de los detalles de su sintaxis.

En *JSON* los objetos se rodean con llaves `{objeto}`, las listas con corchetes `[lista]` y los strings con comillas dobles `"string"`. Por el momento se puede pensar que un objeto es igual a un diccionario de Python, pudiendo almacenar datos con claves, por ejemplo:

```json
{  
  "columna_1": [1, 8, 4, 6, 2, 8, 5],
  "columna_2": [99, 56, 223, 301, 56, 2],
  "columna_2": [0, -1, -66, -210, -333, 334]
}
```

El texto de arriba es cÃ³digo de Python _vÃ¡lido_ y un objeto json! Si quisieramos cargarlo a nuestro cÃ³digo Python bastarÃ­a con copiarlo y pegarlo a nuestro cÃ³digo. Pero no siempre vamos a estar nosotros para copiar y pegar el texto json. 

En el caso presentado a continuaciÃ³n se tiene un string de cÃ³digo json y precisamos [leerlo y procesarlo](https://www.w3schools.com/python/python_json.asp). Para eso usamos el modulo `json` de Python. A continuaciÃ³n se muestra un ejemplo:
"""

import json
s = '{ "a" : [1, 2, 3], "b" : [4, 6, 8], "c":[99, 98, 97] }'
d= json.loads(s)
print(d["a"])
print(len(d["b"]))
print(sum(d["c"]))

"""VerÃ¡n que se imprimen la lista `"a"`, la longitud de la lista `"b"` y la suma de los elementos de la lista `"c"`.

Vamos a utilizar en el prÃ³ximo desafÃ­o **opcional** la librerÃ­a `json` para leer el texto que nos llega por `input()`, lo cual podrÃ­a ocurrir si estamos comunicÃ¡ndonos con un servidor.

### **Opcional**: Mini-desafÃ­o json
EstÃ¡s encargado de un servidor con millones de usuarios. 

Se pide escribir un programa que reciba el email y contraseÃ±a del usuario y se fije si existe el usuario y si coincide la contraseÃ±a.

Se tienen datos encolumnados en formato json que nos llegan en el siguiente formato:
```json
{
	"usuarios" : ["mica@mail.co", "jerry@gma.com","alber@soup.co"],
	"contra" : ["abc123", "caballitos", "yoloswag"]
}
```
La entrada del programa son tres lÃ­neas, el programa entonces va tener tres `input()`. La primer lÃ­nea contiene el `json`, la segunda el `email` a verificar, y la tercera la `contraseÃ±a`. Por ende, las primeras lÃ­neas de su programa podrÃ­an ser:
```python
import json
usuarios = json.loads(input())
email = input()
password = input()
```

La salida del programa serÃ¡ `OK` si el usuario **se encuentra en la base de datos** ***y*** **si coincide la contraseÃ±a**, imprimimos `DNE` (does not exist) si el usuario no existe y `NO` en cualquier otro caso.

#### Caso ejemplo
**Entrada**:
```json
{"usuarios": ["mica@mail.co","jerry@gma.com","alber@soup.co"],"contra": ["abc123","caballitos","yoloswag"]}
mica@mail.co
caballitos
```
El usuario existe y la contraseÃ±a tambiÃ©n... pero no le corresponde la contraseÃ±a `caballitos` al usuario `mica@mail.co` (la contraseÃ±a de `mica@mail.co` serÃ­a `abc123`) por ende imprimimos:

**Salida**
```
NO
```

_Considere que no hay usuarios repetidos_.
"""

import json


usuarios = json.loads(input())
email = input("Mail: ")
password = input("ContraseÃ±a: ")

if email in usuarios["usuarios"]:
  index = usuarios["usuarios"].index(email)
  if password == usuarios["contra"][index]:
    print("OK")
  else:
    print("NO")
else:
  print("DNE")

"""## Anexo B: API's

En este curso, uno de los objetivos es poder automatizar tareas comunes. Ya empezamos a ver cÃ³mo podemos interactuar con archivos de datos desde nuestro programa en Python, pero esto puede no ser suficiente. Es usual tener que interactuar con una aplicaciÃ³n desde nuestro programa, por ejemplo, nuestro programa podrÃ­a querer acceder a una pÃ¡gina web, o al servidor de nuestra empresa. 

Para lograr la interacciÃ³n entre una aplicaciÃ³n y nuestro programa se utilizan API's (Application Programming Interface), las cuales permiten estandarizar el formato de la informaciÃ³n que se intercambia. Para lograr esta comunicaciÃ³n una de las herramientas mÃ¡s comunes es el uso de archivos *JSON* ya que de manera simple y concisa pueden representar estructuras de datos relativamente complejas. 

No todas las aplicaciones tendrÃ¡n API's ya que depende de su creador programar esta interfaz o no, ademÃ¡s, no todas las API's proveen el acceso a todos los datos deseados por lo cual es posible que haya que recurrir a otros mÃ©todos menos elegantes para obtener la informaciÃ³n deseada.

[Este video](https://youtu.be/BxV14h0kFs0) hecho por Tom Scott puede ayudar para comprender un poco mÃ¡s acerca de quÃ© se tratan las API's.

Para mostrar un ejemplo prÃ¡ctico del uso de API's, utilizamos uno de los cÃ³digos de ejemplo en la documentaciÃ³n de la API de YouTube que pueden ver en [este link](https://developers.google.com/youtube/reporting/v1/code_samples/python?hl=es#retrieve_daily_channel_statistics). Las aplicaciones de Google (Maps, Youtube, etc.) suelen tener API's relativamente buenas y completas. En este caso el ejemplo obtiene ciertas estadÃ­sticas del [Canal de YouTube de IEEE-ITBA](https://www.youtube.com/channel/UCpWHvOSiPtDIwIw8Tb_9g6A/featured) entre los dÃ­as 1 y 13 del mes de octubre 2020. Los resultados **reales** de este programa se muestran a continuaciÃ³n tal cual como fueron enviados por la API de YouTube y recibidos por nuestro programa en Python:

```json
{
    "columnHeaders": [
        {
            "columnType": "DIMENSION",
            "dataType": "STRING",
            "name": "day"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "estimatedMinutesWatched"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "views"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "likes"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "subscribersGained"
        }
    ],
    "kind": "youtubeAnalytics#resultTable",
    "rows": [
        [
            "2020-10-01",
            26,
            19,
            0,
            0
        ],
        [
            "2020-10-02",
            2,
            14,
            0,
            0
        ],
        [
            "2020-10-03",
            120,
            78,
            0,
            1
        ],
        [
            "2020-10-04",
            3280,
            1203,
            75,
            88
        ],
        [
            "2020-10-05",
            2064,
            747,
            22,
            44
        ],
        [
            "2020-10-06",
            2290,
            824,
            28,
            26
        ],
        [
            "2020-10-07",
            2817,
            950,
            13,
            20
        ],
        [
            "2020-10-08",
            4594,
            1491,
            9,
            14
        ],
        [
            "2020-10-09",
            4238,
            1254,
            17,
            19
        ],
        [
            "2020-10-10",
            31783,
            3231,
            126,
            102
        ],
        [
            "2020-10-11",
            6233,
            1529,
            18,
            22
        ],
        [
            "2020-10-12",
            4786,
            1138,
            9,
            7
        ],
        [
            "2020-10-13",
            3977,
            761,
            17,
            13
        ]
    ]
}
```

Como se puede observar, el formato de los datos estÃ¡ definido por la API de YouTube, y consiste en una lista ```columnHeaders``` con los datos de cada columna, como por ejemplo el nombre de la columna, y luego una lista ```rows``` con los datos de cada fila en el mismo orden en que se indicaron las columnas.

Usando la API de YouTube, por ejemplo, se puede automatizar el anÃ¡lisis de las estadÃ­sticas de videos e incluso realizar cambios acordemente para mejorar su rendimiento. Por ejemplo: cambiar el tÃ­tulo, la imagen de portada, los subtÃ­tulos, etc. Usando la API de Google Maps se puede llegar a incorporar funcionalidad de mapas o de geolocalizaciÃ³n a nuestra aplicaciÃ³n.

En conclusiÃ³n, las API's nos permiten interactuar desde nuestro programa con otras aplicaciones de forma simple y estandarizada para aprovechar todas las herramientas que nos ofrecen, y podemos automatizar este proceso utilizando Python.

## Anexo C: Algunos Tips extra para Python

A continuaciÃ³n les dejamos un fragmento de una transmisiÃ³n en vivo de aÃ±os anteriores, en la cual se explican diversos trucos y funciones que tiene Python, algunos de los cuales no fueron explicados en la clase pero que pueden serles de utilidad en ciertos casos.

Temas:
* min( ) y max( )
* enumerate
* valor vs. referencia
* tipos mutables e inmutables
* Copiado superficial y en profundidad
"""

# Link a Youtube: https://www.youtube.com/watch?v=YzLOST80M6M

from IPython.display import YouTubeVideo
YouTubeVideo('YzLOST80M6M', start=562, end=2580, width=800, height=450)