# -*- coding: utf-8 -*-
"""Copia de Clase 3 - Introducción a la Programación con Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/112w5vhayTLRsGF-W8kqeVSc14EMhA8UQ

# Clase 3

##Introducción 

En las clases anteriores aprendimos a trabajar con diferentes tipos de variables, funciones, operadores y listas.
En esta clase nos vamos a enfocar en otras estructuras de datos, algo más complejas pero de mucha utilidad. Suele pasar que un problema díficil de resolver con cierta estructura, se vuelve mucho más simple utilizando otra distinta. Por eso es importante aprender a aplicar la herramienta correcta para cada problema, y de esa forma organizar nuestros datos y utilizarlos de la manera más práctica y eficiente.

\

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/data_structures_2.png" alt = "Diagrama de distintas estructuras de datos" height = 300>

## Tuplas

Las tuplas son similares a las listas, pero a diferencia de ellas se dice que las tuplas son *inmutables*, esto quiere decir que sus elementos no pueden cambiar una vez definidos. Se pueden crear usando paréntesis de la siguiente manera:

> a = **(** $ a_{0}, a_{1}, a_{2},\dots $ **)**

Los elementos de una tupla se pueden acceder usando un índice entre corchetes. Al igual que las listas admiten *slicing*.

Cuando creamos una función que devuelve más de un elemento separado por comas, estamos utilizando una tupla inadvertidamente. Cuando intercambiamos 2 elementos de una lista como en los ejemplos de la clase anterior, también aparecen tuplas. Estas son las principales aplicaciones de tuplas, y para concentrarnos en las principales estructuras de datos de Python no ahondaremos en este tema.
"""

tupla = (1, 2, 3)
print(tupla)
print(tupla[0], tupla[1], tupla[2])

# Sacando el primer numeral, la siguiente línea produce un error
#tupla[0] = 10   # Las tuplas NO admiten la asignación por índice

def f(x):
  return x, 2*x, 3*x

print(f(10))

x, y, z = f(10)
print(x, y, z)

x, y, z = z, 0, x
print(x, y, z)

"""## Diccionarios"""

# Link a Youtube: https://youtu.be/Y8eTehVX8fg
# Tema: Diccionarios, cómo estan construidos, operaciones y métodos.

from IPython.display import YouTubeVideo
YouTubeVideo('Y8eTehVX8fg', width=800, height=450)

"""Un diccionario es otra estructura de datos muy útil y muy utilizada cotidianamente. La analogía directa que se suele hacer para explicar diccionarios en programación hace referencia a los diccionarios físicos. Un diccionario (físico) contiene una gran cantidad de información organizada por palabras y contenido asociado a ellas. Más precisamente, cada una de las palabras, ordenada alfabéticamente, tiene información asociada que describe en profundidad su significado. Lo que nos interesa obtener de un diccionario son las definiciones, y la palabra correspondiente es lo que nos ayuda a encontrarlas.

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/pydict.png" alt = "Dictionary PNG" height = 200 title="Diccionario">

En programación los diccionarios no son muy distintos. Un "diccionario" en este contexto es una estructura de datos cuya información esta organizada igual que en un diccionario físico. cada bloque de información, es decir, cada elemento, tiene asociada una palabra. La palabra que se utiliza para encontrar el bloque de información se la suele denominar **key** ó **clave**. Mediante la **clave** se puede acceder a dicha informacion, la cual se suele denominar **contenido**. El par **clave, contenido** suele llamarse **elemento**.

Es muy importante notar que no pueden existir dos elementos con igual clave, estos serían indistinguibles.

La clave suele ser información con tipo de dato string (aunque no necesariamente), mientras que el contenido puede tener cualquier tipo de dato. Los diccionarios se crean utilizando la siguiente estructura:

> x = **{**  $k_{0}$ **:** $c_{0}$**,** $k_{1}$ **:** $c_{1}$, $\dots$**}**
>
> Noten que el "**:**" divide el *key* del *contenido* en cada *elemento*, la "**,**" separa cada par y se enmarca todo entre llaves: **{ }**

Comenzemos por crear un diccionario con la descripción de las palabras:
"""

d = {
    "trueno": "Ruido muy fuerte que sigue al rayo durante una tempestad, \
producido por la expansión del aire al paso de la descarga eléctrica.",
    "rayo": "Chispa eléctrica de gran intensidad producida por la descarga \
entre dos nubes o entre una nube y la tierra."
} 

a = {} # Diccionario vacío

print(d)
print(a)

"""Para acceder a los datos de un diccionario se utiliza la misma sintaxis que las listas pero en lugar de un *índice* numérico, utilizando la *clave* a la que queremos acceder."""

d = {
    "trueno": "Ruido muy fuerte que sigue al rayo durante una tempestad, \
producido por la expansión del aire al paso de la descarga eléctrica.",
    "rayo": "Chispa eléctrica de gran intensidad producida por la descarga \
entre dos nubes o entre una nube y la tierra."
}

print('rayo:')
print(d['rayo'])

"""Tambien podemos usar los diccionarios para acceder de forma sencilla a datos almacenados. Por ejemplo, para acceder a los estudiantes de una universidad a partir de su número de legajo, creamos una base de datos estructurada de la siguiente manera:

> **clave**=Legajo **contenido**=Nombre
"""

database = {
    50001:"Karen Fernandez",
    50002:"Matías Perez",
    50003:"Julieta Gonzalez"
}
print("Nombre completo del legajo", 50002, ":", database[50002])

"""### Operaciones con diccionarios
- clave **in** diccionario: Nos permite saber si esa clave se encuentra en el diccionario.
"""

database = {
    50001:"Karen Fernandez",
    50002:"Matías Perez",
    50003:"Julieta Gonzalez"
}

if 50001 in database:
    print("la clave 50001 se encuentra en el diccionario")

clave = int(input())
if clave in database:
    print(clave, 'está en el diccionario')
else:
    print(clave, 'no está en el diccionario')

"""- **for** clave **in** diccionario: Nos permite iterar por todas las claves del diccionario."""

database = {
    50001:"Karen Fernandez",
    50002:"Matías Perez",
    50003:"Julieta Gonzalez"
}

for clave in database:
    print('La clave',clave,'tiene asociado el valor',database[clave])

"""- **.items**(): Devuelve la lista de claves y valores almacenadas en el diccionario.

 Ya que se obtienen 2 datos por elemento, para utilizarlo en un *for* tendremos que indicar 2 nombres de variable separados por coma. En este ejemplo la variable *k* tomará el valor de la *key* de cada elemento y la variable *c* tomará el valor de cada *contenido*.
"""

database = {
    50001:"Karen Fernandez",
    50002:"Matías Perez",
    50003:"Julieta Gonzalez"
}

# Pueden quitar el comentario de la siguiente línea y ver qué imprime
# print(database.items())

for k,c in database.items():
    print("key:", k," content: ",c)

# Otra forma

for item in database.items():
    print("key:", item[0]," content: ",item[1])

"""

* diccionario**[** clave **]** = valor: Agrega un nuevo elemento a un diccionario. Si ya existía un valor asociado a esta clave, será reemplazado por el nuevo valor.
"""

x = {
    'año':2021,
    'mes':12
}

x['dia'] = 24
print(x)

x['mes'] = 'Diciembre'
x['horas'] = 23
x['minutos'] = 59
print(x)

"""- **.get**( clave, valor_por_defecto ): Devuelve el valor asociado a la clave. Si la clave *no* se encuentra el diccionario, devuelve el valor por defecto indicado. Esto es útil cuando no sabemos si una clave existe o no."""

texto = "lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod \
tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, \
quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi \
consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore \
eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt \
in culpa qui officia deserunt mollit anim id est laborum."

ocurrencias = {}
for letra in texto:
  if letra.isalpha(): # Solo importan letras, no comas, puntos, espacios, etc.
    letra = letra.upper() # No nos importa si es minúscula o mayúscula
    # Suma 1 a las ocurrencias de 'letra', o inicializa el elemento
    ocurrencias[letra] = ocurrencias.get(letra, 0) + 1

# De esta forma averiguamos la cantidad de ocurrencias de cada letra.
for k,c in ocurrencias.items():
    print("La letra", k, "aparece", c, "vez/veces.")

"""#### **Mini-desafío:** Diccionarios
1. Realizar un programa que pida al usuario un número de legajo y el nombre completo, luego los guarde en un diccionario. En caso de que el número de legajo ya se encuentre en el diccionario, se debe mostrar un mensaje de advertencia.

 Usar dos celdas de código, en una crear el diccionario, y en la otra agregar el nombre y legajo y mostrar el contenido total. La idea es que cuando se ejecute varias veces la segunda celda se agrege un nuevo nombre y legajo a lo que ya había sido almacenado en el diccionario.
"""

# Celda 1
# Ejecutar esta celda 1 vez para crear el diccionario vacío
dic = {}
print(dic)

# Celda 2
# Ejecutar esta celda cada vez que se quiera agregar un elemento

legajo = int(input("Ingrese el numero de legajo: "))
nombre = input("Ingrese el nombre completo: ")

if legajo in dic:
  print("Ese alumno ya esta registrado.")

else:
  dic[legajo] = nombre

print(dic)

"""2. Realizar un programa que decodifique [código morse](https://es.wikipedia.org/wiki/C%C3%B3digo_morse). El usuario debe ingresar una palabra en código morse, usando una secuencia de puntos, guiones y espacios como la siguiente:

  ```.--. .-. --- --. .-. .- -- .- -.-. .. --- -.```
  
  Luego, separando por espacios, cada letra debe ser convertida de morse a una letra del alfabeto, y por último la traducción se muestra en pantalla como un *string*. Les proponemos definir un *diccionario* que ayude a realizar la traducción. Es importante considerar qué dato será la clave, y cuál el contenido, de forma en que les sea más útil para lograr resolver el desafío.

  **Tips:** Revisar los métodos `.split()` y `.join()` para convertir entre strings y listas.
"""

# Solución

morse_code = {'.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', 
              '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', 
              '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', 
              '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', 
              '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', 
              '--..': 'Z'}

frase = '.--. .-. --- --. .-. .- -- .- -.-. .. --- -.'

letras = frase.split()

for i in range(len(letras)):
  letras[i] = morse_code[letras[i]]

print( ''.join(letras) )

"""### Nota final
Es importante ver que un diccionario tiene un cierto orden, al igual que las listas. Por otro lado, también aceptan contenidos repetidos y todo marchará correctamente siempre que no se repitan las claves. Uno de los dilemas más comunes cuando se trabaja con grandes volúmenes de información es qué tomar como clave.

En la próxima sección veremos un tipo de datos que ya no organizará la información de manera tal que exista un orden establecido. En algunos casos es provechoso que la información se estructure de manera tal que no exista un orden en los elementos.

## Sets
"""

# Link a Youtube: https://youtu.be/EAyOH2EwI3w
# Tema: Sets, cómo estan construidos, operaciones y métodos.

from IPython.display import YouTubeVideo
YouTubeVideo('EAyOH2EwI3w', width=800, height=450)

"""Un **set** es una estructura de datos más avanzada que las anteriores, la cual nos permite almacenar un grupo de elementos cuyo orden no es relevante. Lo único que tiene importancia cuando utilizamos un **set** es qué elemento está y qué elemento no. 

<img src="https://files.realpython.com/media/t.8b7abb515ae8.png" height = 200 alt = "Representación de Set usando diagrama Venn" title= "A&B">


Un **set** no admite repetidos, ya que por su funcionamiento interno no tiene la capacidad de determinar cuando un elemento se encuentra más de una vez. Solo se puede saber qué elementos están y qué elementos no.
A primera vista parecería entonces que un **set** es muy limitado, ya que no está ordenado y no acepta repetidos. No obstante, este es muy práctico para algunos tipos de operaciones, las cuales serían muy tediosas de  programar en listas o diccionarios.

Para crear un **set** se utilizan llaves **{ }** y se colocan elementos separados por comas, su sintaxis es similar a la de las listas.

"""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}   # Los sets no admiten elementos repetidos
print("Set x =", x)

"""### Operaciones con sets
- **|** : Es la operacion de $A \cup B$ llamada "*unión*".
"""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
z = {15, 20}

k = x | y | z
print(k)

"""
-  **&**: Es la operacion de $A \cap B$ llamada "*intersección*"."""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
w = x & y
print(w)

"""- **A-B**: todo elemento de A que también se encuentre en B, será quitado de A. El equivalente logico es $ A\cap \neg B$."""

x = {1, 2, 3, 4, 7, 7, 7, 7, 7, 7}
y = {1, 2, 10}
z = x - y
print(z)
print(y - x)

"""- **.remove**($valor$): Remueve el valor del set."""

x = {1, 2, 3, 4, 7}
x.remove(1)
print(x)

"""- **.add**($valor$): Agrega el valor al set."""

x = {1, 2, 3, 4, 7}
x.add("hola")
print(x)

"""- **len**($set$) Obtiene el tamaño de un set."""

conjunto = {1, 2, 1, 3, 1, 6}
print(conjunto)
print(len(conjunto))

"""- **.issubset**($set$): Analiza si un set está contenido dentro de otro."""

x = {1, 2, 3, 4, 5, 6, 7, 8, 9}
y = {8, 9, 10}
z = {4, 8}


print(z.issubset(x))
print(y.issubset(x))

"""#### **Mini-desafío:** Sets
1. Se cuentan con varios sets que contienen nombres de personas a las que les gusta un cierto sabor de helado:

  ```python
vainilla = { "Juan", "Marina", "Tomas", "Paula" }
chocolate = { "Pedro", "Paula", "Marina" }
dulceDeLeche = { "Juan", "Julian", "Pedro", "Marina" }
```

  Responder, usando operaciones de sets:

  - ¿Hay alguna persona a la que le gusten todos los sabores?

  - ¿Hay alguna persona a la que le guste la vainilla y no el dulce de leche?

  - ¿Cuántas personas distintas tenemos?


2. Diseñar un programa que analiza si una frase es un [pangrama](https://es.wikipedia.org/wiki/Pangrama) del idioma inglés, es decir, si contiene todas las letras del alfabeto al menos 1 vez. El programa debe ser capaz de ignorar espacios y signos de puntuación. Por ejemplo:
```python
frase = "the quick brown fox jumps over the lazy dog"
```
  El siguiente set puede serles de utilidad:
  ```python
  letras = set("abcdefghijklmnopqrstuvwxyz")
  ```
"""

# Solución - parte 1

vainilla = {"Juan", "Marina", "Tomas", "Paula"}
chocolate = {"Pedro", "Paula", "Marina"}
dulceDeLeche = {"Juan", "Julian", "Pedro", "Marina"}

print("Le gustan todos los sabores a:", vainilla & chocolate & dulceDeLeche)

print("Le gusta la vainilla y no el dulce de leche a:", vainilla - dulceDeLeche)

print("Total de personas:", len(vainilla | chocolate | dulceDeLeche))

# Solución - parte 2

letras = set("abcdefghijklmnopqrstuvwxyz")

frase = input("Ingrese una frase: ")

if letras.issubset( set(frase) ):
  print("La frase es un pangrama del idioma inglés!")
else:
  print("La frase no es un pangrama.")

"""## Librerías

Como último tópico del curso, hablaremos del uso de librerías y mostraremos diversos ejemplos. No es para que se los aprendan de memoria, sino para que conozcan estas herramientas y puedan aprender a utilizar nuevas librerías en el futuro, en base a sus necesidades particulares.

"""

# Link a Youtube: https://youtu.be/frIIOnzvdHs
#Tema: Librerías: concepto, instalación, importación y ejemplos. 

from IPython.display import YouTubeVideo
YouTubeVideo('frIIOnzvdHs', width=800, height=450)       #Video Librerías

"""Una *librería* o *biblioteca* es un conjunto de funciones implementadas por otro programador que nos facilitan realizar tareas, principalmente porque no debemos volver a programar este código. 

<img src="http://www.goalexandria.com/wp-content/uploads/2016/02/alt-lib.png" width=200px>

*¿Como usamos una librería?* Primero debemos importarla, para lo cual tenemos opciones. A continuación, se expone la sintaxis general junto con un ejemplo:

* Opción 1: importar una librería, sin alias.

  > **import** (nombre de la libreria) 

  ```python
  import math

  ```

* Opción 2: importar una librería, con alias.

  > **import** (nombre de la libreria) **as** (nombre abreviado)

  ```python
  import pandas as pd

  ```

Las librerías muchas veces están separadas en distintos módulos. Podríamos decir que la librería es como un estante de libros, y en cada libro se encuentran las funciones de un tema en común, incluso un "libro" podría estar subdividido en "capítulos". Es decir, los distintos módulos de una librería podrían llegar a estar subdivididos en módulos, y cada módulo podría estar nuevamente subdividido.

Si lo que queremos son módulos o funciones particulares de una librería, podemos importar de a uno o más de diversas formas.

* Opción 1: importar un módulo o función, sin alias.

  > **from** (nombre de la libreria) **import** (nombre de un módulo)

  ```python
  from random import randint

  ``` 

* Opción 2: importar más de un módulo o función.

  > **from** (nombre de la libreria) **import** (nombre de un módulo), (nombre de otro módulo), ...

  ```python
  from random import randint, randrange

  ``` 

* Opción 3: importar un módulo o función, con un alias.

  > **from** (nombre de la libreria) **import** (nombre de un módulo) **as** (nombre abreviado)

  ```python
  from matplotlib import pyplot as plt

  ``` 

* Opción 4: importar un módulo o función, con un alias, otra forma.

  > **import** (nombre de la libreria)**.**(nombre de un módulo) **as** (nombre abreviado)

  ```python
  import matplotlib.pyplot as plt

  ``` 

* Opción 5: importar todos los módulos o funciones de una librería.

  > **from** (nombre de la librería) **import** * (todo)

  ```python
  from numpy import *

  ``` 

Una vez importada la librería, podremos utilizar las funciones y variables definidas en ella. La utilización de una función o variable dependerá de cómo hayamos realizado la importación. Ejemplos:

* Si se importó una librería o módulo:
  > (nombre de la libreria/módulo)**.**función*(argumentos)*

  > (nombre de la libreria/módulo)**.**(nombre de la variable)

  ```python
  import math

  print(math.sin(math.pi / 2))

  ```

* Si se importó una función o variable:
  > función(argumentos)

  > variable 

  ```python
  from math import sin, pi

  print(sin(pi / 2))

  ```

* Si se importó una librería dividida en módulos:

  > (nombre de la libreria)**.**(nombre del módulo)**.**función*(argumentos)*

  ```python
  import matplotlib

  datos = [i for i in range(-10, 10)]
  print(matplotlib.pyplot.plot(datos, datos))

  ```


**Notas:**
- No es obligatorio especificar un nombre abreviado con **as**, puede utilizarse una librería con su nombre original omitiendo este comando.
- No sólo pueden importarse módulos de una librería, sino también funciones sueltas, según lo que necesiten. Siempre tengan cuidado de que los nombres de función sean únicos. Si importan una función directamente entonces no querrán definir su propia función con el mismo nombre.
- Es una buena práctica que todas las librerías se importen al principio del programa, o sea que las instrucciones de **import** se encuentren arriba de todo.


**Ejemplos:**
"""

import math  # Importamos la libreria math

print('El seno de 0 es ', math.sin(0), 'y el coseno', math.cos(0))

from math import sin, cos  # Importamos directamente las funciones que usaremos 
print('El seno de 0 es ', sin(0), 'y el coseno', cos(0))

import math as m  # Importamos la libreria math abreviada como m

print('El seno de 0 es ', m.sin(0), 'y el coseno', m.cos(0))

# En este caso usamos el módulo 'path' de la librería 'os' y lo apodamos 'pth'
from os import path as pth

print(pth.join('Carpeta','Archivo.rar'))

"""Algunas librerías muy conocidas y utilizadas son:


*   [numpy](https://numpy.org/) (Cálculo matricial)
*   [pandas](https://pandas.pydata.org/) (Lectura de bases de datos)
*   [maplotlib](https://matplotlib.org/) (Gráficos)
*   [tkinter](https://docs.python.org/3/library/tk.html) (Interfaces gráficas)
*   [Qt](https://www.qt.io/qt-for-python) (Interfaces gráficas)
*   [scipy](https://www.scipy.org/) (Ciencia de datos)
*   [scikit-learn](https://scikit-learn.org) (Machine Learning)
*   [TensorFlow](https://www.tensorflow.org/) (Machine Learning avanzado)

En IEEE-ITBA ofrecemos un curso más avanzado como continuación de este curso introductorio, en donde se utiliza **Pandas** para analizar archivos de información estructurada, como lo es el formato de hojas de datos de **Excel**, y **Matplotlib** para realizar gráficos y visualizar información. Pueden enterarse de novedades respecto a todos nuestros eventos a través de nuestra cuenta de [Instagram](https://www.instagram.com/ieee.itba/).


A continuación les ofrecemos un conjunto de ejemplos con diversas librerías. Por supuesto que para cada una de ellas existen muchas más cosas al respecto, pero esperamos que les ayude a tener una mejor idea del tipo de herramientas que existen, y que se animen a buscar nuevas librerías cuando tengan que solucionar problemas específicos. Algunas de estas librerías ya vienen incluídas con la instalación de Python mientras que otras deben ser instaladas de forma independiente. En [este link](https://docs.python.org/3/library/) pueden investigar acerca de todas las librerías estándar que trae Python.

Si cierta librería no se encuentra instalada en el sistema, entonces el comando *import* para esa librería no funcionará. Usando la herramienta **pip** se pueden instalar librerías nuevas. En este ejemplo, al ejecutar el siguiente bloque de código se instalan las librerías *numpy* y *pandas* en el entorno de Google Colab.
"""

! pip install numpy
! pip install scipy

"""#### [copy](https://docs.python.org/3/library/copy.html)

* *Copiado en profundidad de estructuras de datos*

Por defecto Python NO copia estructuras de datos, para ahorrar memoria:
"""

A = [1, 2, 3]
B = A
B += [4, 5, 6]

# No modificamos directamente A, sin embargo su valor cambió
# En este caso, 'B' es un nombre alternativo de 'A', no es una copia
print(A)
print(B)

"""Usando el método **.copy()** realizamos una copia real:"""

A = [1, 2, 3]
B = A.copy()
B += [4, 5, 6]

print(A)
print(B)

"""Usando sólo **.copy()** no alcanza para que se copien las estructuras internas. Esto se llama una copia *superficial*, solamente la capa "externa" es la que se copia."""

A = [[1,2,3], [4,5,6], [7,8,9]]
B = A.copy()
B[0][0] = 999
B += [10, 11, 12]

print(A)
print(B)

"""Con **copy.deepcopy()** realizamos una copia real *en profundidad*:"""

import copy

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
B = copy.deepcopy(A)
B[0][0] = 999
B += [10, 11, 12]

# La lista A se mantiene intacta
print(A)
print(B)

"""#### [random](https://docs.python.org/3/library/random.html)

* *Generación aleatoria de números*
"""

import random

# Elige entre elementos de una lista
opciones = ['Manzanas', 'Bananas', 'Naranjas']
print( random.choice(opciones) )

# Número entero entre 10 y 20
print( random.randint( 10, 20 ) )

# Número real que pertenece al intervalo [0, 1)
print( random.random() )

# Número real con distribución gaussiana de media 0 y desvío estándar 1
print( random.gauss(0, 1) )

"""#### [time](https://docs.python.org/3/library/time.html)

* *Funciones relacionadas al manejo del tiempo*
"""

import time

print(1)
time.sleep(1)
print(2)
time.sleep(1)
print(3)
time.sleep(1)
print(4)
time.sleep(1)
print(5)
time.sleep(1)
print('Adiós!')

"""#### [datetime](https://docs.python.org/3/library/datetime.html)

* *Manipulación de fechas y horarios*
"""

from datetime import datetime, timedelta

now = datetime.now()
print(now)
print(now.time())

new_time = datetime(2010, 2, 6, 10, 8, 20, 0)
print(new_time)
new_time += timedelta(days=31, hours=1)
print(new_time)

"""#### [csv](https://docs.python.org/3/library/csv.html)

* *Manipulación de archivos CSV*
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/datos.csv"

import csv

csvfile = open('datos.csv')
lector = csv.reader(csvfile)
for fila in lector:
  print(fila)

"""#### [NumPy](https://numpy.org/)
* *Cálculo algebraico*

NumPy permite crear vectores y matrices multidimensionales, junto con una gran colección de funciones matemáticas de alto nivel para operar con ellos de forma muy eficiente.
"""

import numpy as np

A = np.array(([1, 2, 3], [4, 5, 6]))
B = np.array(([1, 2], [4, 5], [7, 8]))
C = np.dot(A, B)

print('A =')
print(A)
print()
print('B =')
print(B)
print()
print('A.B =')
print(C)

"""#### [Matplotlib](https://matplotlib.org)
* *Visualización de datos*

Matplotlib permite representar datos de forma gráfica y cuenta con una gran cantidad de tipos y formatos de gráficos para utilizar. Permite crear visualizaciones estáticas, animadas ó interactivas.
"""

# Ejemplo provisto por matplotlib para darse una idea del uso de esta herramienta
# No es necesario entender cómo funciona

import matplotlib
import numpy as np
import matplotlib.pyplot as plt

# example data
mu = 100  # mean of distribution
sigma = 15  # standard deviation of distribution
x = mu + sigma * np.random.randn(437)

num_bins = 50

fig, ax = plt.subplots(figsize=(10, 5))

# the histogram of the data
n, bins, patches = ax.hist(x, num_bins, density=True)

# add a 'best fit' line
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) *
     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
ax.plot(bins, y, 'r--')
ax.set_xlabel('Value')
ax.set_ylabel('Probability density')
ax.set_title(r'Histogram of random samples: $\mu=100$, $\sigma=15$')

# Tweak spacing to prevent clipping of ylabel
fig.tight_layout()
plt.show()

"""## Para seguir aprendiendo...

Como contenido extra, sólo para aquellos interesados en seguir investigando contenido relacionado, incluímos 2 Anexos al final de la clase que se relacionan con el formato *JSON*.

Además, al final de la clase podrán encontrar a modo de anexo, fragmentos de transmisiones en vivo de años anteriores que podrían ser de su interés.

La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

# **¿Cómo seguir después del curso?**

En este curso introductorio aprendimos las bases del lenguaje Python y de a poco comenzamos a realizar aplicaciones prácticas. En IEEE-ITBA ofrecemos un curso más avanzado en el cual se explica en profundidad la manipulación de archivos de hojas de datos (Excel) y la visualización de datos mediante Matplotlib. Nuestro objetivo es que puedan aprender lo suficiente para crear aplicaciones simples, pero de gran utilidad. Esperamos que sientan que ya son programadores de Python y que puedan terminar el curso con buenas primeras experiencias y ganas de realizar proyectos ambiciosos. No está de más recordar que en este mundo el conocimiento no lo es todo, se aprende sobre la marcha y no hay que temer a emprender proyectos que utilicen herramientas novedosas las cuales hasta ahora nunca utilizaron. Si lograron terminar este curso es que supieron adaptarse a nuevos desafíos y no hay razón por la cual no puedan enfrentarse a lo que se propongan.

Ya que el universo de cosas para aprender es infinito, y que este curso es introductorio, nos parece oportuno comentar algunas de las cosas que le puede interesar a todo aquel que quiera seguir especializándose en este lenguaje en el futuro:

- Clases y Programación Orientada a Objetos:
 - [A Byte of Python](https://python.swaroopch.com/oop.html)
 - [RealPython](https://realpython.com/python3-object-oriented-programming/)
 - [Docs Python](https://docs.python.org/3/tutorial/classes.html)
 - [Video de Matías Bergerman](https://youtu.be/ZB9brIzJU7c)
- Excepciones: instrucciones `try`, `except`, `finally`, `with`:
 - [A Byte Of Python](https://python.swaroopch.com/exceptions.html)
 - [RealPython](https://realpython.com/python-exceptions/)
 - [Docs Python](https://docs.python.org/3/tutorial/errors.html)
- Funciones Lambda:
 - [RealPython](https://realpython.com/python-lambda/)
 - [W3Schools](https://www.w3schools.com/python/python_lambda.asp)
 - [Video de Matías Bergerman](https://youtu.be/4jy4ADH_7i0)

\

## Propuestas de proyectos
En el [último capítulo](https://python.swaroopch.com/what_next.html) del libro A Byte of Python se ofrecen muchos recursos que pueden resultarles muy interesantes: propuestas de proyectos, videos para ver, consejos, tutoriales, recursos para creación de páginas web e interfaces gráficas, y algunas cosas más.

Hacer un proyecto de cierta complejidad definitivamente será un desafío, les proponemos intentar dividir su proyecto en partes, sub-tareas, y resolver cada problema por separado antes de unir todas las partes. También es muy recomendable buscar información e investigar acerca de los temas que no conocen, además de pedir ayuda o preguntar en foros cuando lo necesitan, ¡nadie programa solo!

Les proponemos a continuación algunas otras ideas de proyectos que se nos ocurrieron por si alguno les llama la atención, que podrían hacer con los conocimientos adquiridos en el curso e investigando algunas herramientas nuevas:

- **Pomodoro Timer**

  El objetivo del proyecto es crear una aplicación para utilizar la [técnica pomodoro](https://es.wikipedia.org/wiki/T%C3%A9cnica_Pomodoro) de administración de tiempo. El programa debe poder cronometrar bloques de 25 minutos de concentración intercalados con 5 minutos de descanso, si desean estos tiempos podrían ser customizables. Adicionalmente, podrían hacer una interfaz gráfica para la aplicación. Una alternativa para esto es la librería [tkinter](https://docs.python.org/3/library/tkinter.html), para comenzar a usarla les recomendamos empezar por un tutorial como el de [RealPython](https://realpython.com/python-gui-tkinter/).

- **Web Scrapping**

  El objetivo del proyecto es obtener información de una página en forma sistemática, especialmente cuando esta página no provee una forma fácil de obtener los datos en forma escalable. Por ejemplo, se pueden analizar los precios/reviews/preguntas de cientos de miles de productos en una página de e-commerce en forma automática con Python. Para esto les recomendamos investigar acerca de la librería [Selenium](https://selenium-python.readthedocs.io/) y seguir un tutorial la primera vez que la usan.

- **Cálculo del factor de transmisión del coronavirus**

  El objetivo es automáticamente descargar los datos actualizados de casos de coronavirus diarios en el país (usando por ejemplo `wget`), abrir el archivo con la librería `csv` o alguna similar, y calcular parámetros de interés como el factor de transmisión R, o la tasa de duplicación de casos. Pueden usar una página como [Our World In Data](https://covid.ourworldindata.org/data/owid-covid-data.csv) para obtener la información.

- **Bot de Instagram**

  La idea del proyecto es automatizar actividades realizadas en instagram mediante una aplicación de Python. Para esto les recomendamos investigar la librería [InstaPy](https://instapy.org/). También hay una introducción interesante a la librería hecha por [RealPython](https://realpython.com/instagram-bot-python-instapy/).

- **Filtro de imágenes personalizado**

  Utilizar una librería de manipulación de imágenes para aplicar un filtro especial a las imagenes indicadas, o todas las imagenes dentro de cierta carpeta. Les sugerimos investigar acerca de la librería [Pillow](https://python-pillow.org/). El filtro podría ser un difuminado, blanco y negro, agregar un watermark o ser tan sofisticado como quieran. También podrían darle la opción al usuario de elegir el filtro que quiere aplicar dentro de un listado.

## **Casos de aplicación**

Como conclusión, les mostramos a continuación algunos ejemplos de aplicación de **Python** realizados por miembros del equipo organizador, por si les llegan a interesar:

### **Resolución de EDOs - Ejercicio de Reactores I**
*Ariel Nowik, Joaquin Mestanza, Tomas Wierzba*

Resolvemos una ecuación diferencial de una materia de Química mediante un script de Python en lugar de la manera "tradicional" con un excel. Muchas veces utilizar un script es más práctico y versátil ya que se puede integrar con otras funcionalidades del lenguaje.

([Código aqui](https://github.com/jmestanza/ideas/tree/master/QuimicaEdos)) 


### **Web scrapper - página web del itba**
*Ariel Nowik*

Un scrapper es un script capaz de extraer información y escribir información en una página web (es un bot). Este código de python analiza la página del itba para conseguir información de las distintas materias de forma automática.

([Código aqui](https://github.com/elgrandt/CalificaProfesores-Utils/blob/master/scrapping/itba.py))

### **CalcuPy**
*Matías Bergerman*

Una simple calculadora por consola programada en Python. Implementa clases y una [estructura de árbol](https://es.wikipedia.org/wiki/%C3%81rbol_(inform%C3%A1tica)) para representar expresiones matemáticas.

([Código aqui](https://github.com/mbergerman/CalcuPy/blob/main/calcu.py))

### **Book Selector**
*Ignacio Vidaurreta*

Este script elige un libro al azar para que el usuario lea uno nuevo.

([Código aqui](https://github.com/ignacioVidaurreta/bookSelector))

### **Piedra papel o tijera**
*Ignacio Vidaurreta*

Este script es un juego (por consola) de piedra papel o tijera.

([Código aqui](https://github.com/ignacioVidaurreta/rockPaperScissors/blob/master/rps.py))

### **Método de los Elementos Finitos**
*Patricio Whittingslow*

Calcula deformaciones para una estructura reticulada con cargas.

([Código aqui](https://colab.research.google.com/drive/12ZVTs7eIwoIAS_IIi68O-YoDzCfQ629u)).

### **Herramienta para graficar funciones de transferencia**
*Matías Bergerman, Pedro Carranza Vélez, Pablo González*

Interfaz gráfica hecha con Qt para comparar curvas de transferencia medidas, simuladas y calculadas de forma teórica.

([Código aqui](https://github.com/pabgonzalez/Plot_Tool))

# $\color{\green}\blacktriangleright$ Desafío a Entregar: Las Elecciones

*Los desafíos se entregan mediante [esta página](https://www.hackerrank.com/2022-1c-curso-introductorio-de-python) de HackerRank. Pueden ver un instructivo acerca del uso de la plataforma en [este link](https://youtu.be/pqYSwABnS_k).*

Realizar un programa en el cual se decida el ganador de unas **elecciones**.

El programa primero recibe un número $N$, la cantidad de votos totales que se realizaron. Luego recibe $N$ votos en formato string, cada uno consiste en el nombre del candidato seleccionado. El programa debe calcular el ganador e imprimir su nombre. Para este ejemplo se asume que no hay empates. Los nombres y la cantidad de candidatos es desconocida.

**Ejemplo:**

- *Input:*

 ```python
12
Mickey
Donald
Mickey
Minnie
Mickey
Goofy
Daisy
Goofy
Goofy
Minnie
Goofy
Donald
```

- *Output:*

 ```
 Goofy
 ```
 El resultado es Goofy ya que este recibe 4 votos, la cual es la mayor cantidad de votos.
"""



"""# Ejercitación integradora $\newcommand{\dif}{\bigstar}$$\newcommand{\facil}{\color{\green}{\dif}}$ $\newcommand{\pieceofcake}{\color{\cyan}{\dif}}$$\newcommand{\medio}{\color{\yellow}{\dif\dif}}$$\newcommand{\media}{\medio}$$\newcommand{\normal}{\medio}$  $\newcommand{\dificil}{\color{\orange}{\dif\dif\dif}}$ $\newcommand{\imposible}{\color{\red}{\dif\dif\dif\dif}}$
$\newcommand{\tarc}{\large\frown}$
$\newcommand{\arc}[1]{\stackrel{\tarc}{#1}}$
<head>
<style type="text/css">
  .img{ 
    display: block;
    margin-left:auto;
    margin-right:auto;
  }
  </style>
  </head>

A continuación les proponemos resolver algunos ejercicios integradores. Este contenido servirá para poder practicar lo aprendido y de a poco acercarse a lo que podría ser una aplicación real. No se preocupen si no llegan a terminar todos, o si les cuestan más que los desafíos de la clase. Es cuestión de tomarse el tiempo de leer, pensar, y probar diferentes ideas hasta que encuentren una posible solución al problema.

Luego de una semana les enviaremos una copia de las soluciones que se nos ocurrieron a nosotros para resolver estos problemas y poder comparar en caso de que lo deseen.

### $\facil$ El ABC de Python

*Aclaración: Este desafío es inventado, es posible que haya errores fácticos en cuanto a los alfabetos reales.*

Encontramos una piedra antigua en una plaza de Buenos Aires cuyas inscripciones nos ayudan a decifrar nuevos alfabetos. Gracias a estas inscripciones descubrimos que las letras del [alfabeto latino arcaico](https://es.wikipedia.org/wiki/Alfabeto_latino#Alfabeto_latino_arcaico) tienen una correspondencia con el [alfabeto latino](https://es.wikipedia.org/wiki/Alfabeto_latino) y vamos a crear un programa que nos ayude a traducir palabras de un alfabeto a otro.

Crear una función que recibe un *string*, transforma todos los caracteres del *alfabeto latino arcaico*  en caracteres modernos, no modifica el resto de los caracteres (signos de puntuacion, espacios, letras, números, etc.) y devuelve el resultado con *return*.

**Ejemplos:**

`traducir( "𐌀𐌋𐌅𐌀𐌁𐌄𐌕𐌏" )` → `"ALFABETO"`

`traducir( "¡𐌐𐌄𐌓𐌃𐌉!" )` → `"¡PERDI!"`

`traducir( "¿𐌔𐌉 𐌏 𐌍𐌏? 𐌌𐌌𐌌... 𐌔𐌉." )` → `"¿SI O NO? MMM... SI."`

**Correspondencia entre alfabetos:**
```python
Arcaico : Moderno
'𐌀' : 'A',
'𐌁' : 'B',
'𐌂' : 'C',
'𐌃' : 'D',
'𐌄' : 'E',
'𐌅' : 'F',
'𐌆' : 'Z',
'𐌇' : 'H',
'𐌉' : 'I',
'𐌊' : 'K',
'𐌋' : 'L',
'𐌌' : 'M',
'𐌍' : 'N',
'𐌏' : 'O',
'𐌐' : 'P',
'𐌒' : 'Q',
'𐌓' : 'R',
'𐌔' : 'S',
'𐌕' : 'T',
'𐌖' : 'V',
'𐌗' : 'X'
```
"""

arcaico = {'𐌀' : 'A', '𐌁' : 'B', '𐌂' : 'C', '𐌃' : 'D', '𐌄' : 'E', '𐌅' : 'F',
           '𐌆' : 'Z', '𐌇' : 'H', '𐌉' : 'I', '𐌊' : 'K', '𐌋' : 'L', '𐌌' : 'M',
           '𐌍' : 'N', '𐌏' : 'O', '𐌐' : 'P', '𐌒' : 'Q', '𐌓' : 'R', '𐌔' : 'S',
           '𐌕' : 'T', '𐌖' : 'V', '𐌗' : 'X' }

def traducir(texto):
  resultado = ""
  for letra in texto:
    if letra in arcaico:
      resultado += arcaico[letra]
    else:
      resultado += letra
  return resultado

print(traducir("𐌀𐌋𐌅𐌀𐌁𐌄𐌕𐌏"))
print(traducir("¡𐌐𐌄𐌓𐌃𐌉!"))
print(traducir("¿𐌔𐌉 𐌏 𐌍𐌏? 𐌌𐌌𐌌... 𐌔𐌉."))
print(traducir("𐌀𐌋𐌅𐌀𐌁𐌄𐌕𐌏, ¡𐌐𐌄𐌓𐌃𐌉!, ¿𐌔𐌉 𐌏 𐌍𐌏? 𐌌𐌌𐌌... 𐌔𐌉."))

"""###$\facil$ Análisis estadístico de fallas en lotes de producción II

Adaptar la solución al ejercicio integrador de la clase pasada para utilizar librerías en lugar de programar todo de forma manual. Pueden usar la librería **csv** para importar el archivo, y las librerías **numpy** o **scipy** para calcular la media, varianza, moda y mediana.

**Tip:** Pueden investigar el uso de estos métodos en la documentación de las librerías:

* Media: [numpy.mean](https://numpy.org/doc/stable/reference/generated/numpy.mean.html)
* Varianza: [numpy.var](https://numpy.org/doc/stable/reference/generated/numpy.var.html)
* Moda: [scipy.stats.mode](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mode.html)
* Mediana: [numpy.median](https://numpy.org/doc/stable/reference/generated/numpy.median.html)

A continuación pueden ver una copia de la consigna:

Una planta de producción de botellas plásticas fabrica 1000 lotes de botellas por día. Debido al proceso de fabricación algunas de las botellas salen falladas. Estos fallos son detectados automáticamente durante el proceso de control de calidad y se cargan en una base de datos que registra la cantidad de productos fallados por cada lote. El departamento de control de calidad sospecha que la cantidad de fallos por lote sigue una distribución de *Poisson*, pero todavía no conocen la media y la varianza.

Se pide importar los datos de los últimos 30 días (en total son 30000 datos) y calcular la *media*, la *varianza*, la *moda* y la *mediana* de la distribución de datos medidos. Los datos se encuentran en el archivo *ControlCalidadBotellas.csv* bajo la columna *Fallas*.

**Definiciones:**
- **Media:** El valor promedio:

  $\mu=\frac{X_1+X_2+X_3+\cdots+X_n}{n}$

- **Varianza:** El promedio de las distancias al cuadrado entre cada valor y la media:

  $\sigma^2=\frac{(X_1-\mu)^2+(X_2-\mu)^2+\cdots+(X_n-\mu)^2}{n}$

- **Moda:** El valor que ocurre con mayor frecuencia.

- **Mediana:** El valor que cumple la propiedad que la mitad de las veces el valor medido es menor a la mediana y la otra mitad de las veces es mayor.

Si las sospechas acerca de la distribución fueran correctas, entonces de acuerdo a las propiedades de la distribución de Poisson la media y la varianza deberían ser iguales. Además la moda sería $\lceil{\mu}\rceil-1$. ¿Esta sospecha les parece acertada?
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/ControlCalidadBotellas.csv"

# Instalar las librerías en el entorno de Colab
! pip install numpy
! pip install scipy

import csv
import numpy
from scipy import stats

# Lectura del archivo
csvfile = open("ControlCalidadBotellas.csv")
lector = csv.reader(csvfile)

# Armo una lista con laa cantidad de fallas por día
fallas = []
for fila in lector:
  if fila[1] != "Fallas":
    fallas.append( int(fila[1]) )

# Cálculo de las diferentes métricas
media = numpy.mean(fallas)
var = numpy.var(fallas)
moda, count = stats.mode(fallas)
mediana = numpy.median(fallas)

print("La media es:", media)
print("La varianza es:", var)
print("La moda es:", moda[0])
print("La mediana es:", mediana)

"""### $\facil$ Diccionario²
Se recibieron distintos postulantes para un empleo de traductor. Crear un **diccionario** en el cual la *clave* de cada elemento sea el nombre de un candidato y el *contenido* sea un **diccionario** de los idiomas que aprendió. Para armar el diccionario de idiomas de cada candidato, los elementos deben tener como *clave* el nombre del idioma y como *contenido* el valor True o False para los siguientes idiomas: Español, Inglés, Chino, Frances, Italiano.

Ejemplo del **diccionario** de idiomas:

```python
{"Español":True, "Inglés":True, "Chino":False, "Frances":False, "Italiano":True}
```

Inventar valores para 5 candidatos.

El usuario luego debe poder ingresar el nombre de un idioma y el programa deberá mostrar en pantalla el nombre de aquellos candidatos que aprendieron ese idioma.
"""

postulantes = {
    "Juan" : {"Español":True, "Ingles":True, "Chino":False, 
              "Frances":False, "Italiano":True}, 
    "Pablo" : {"Español":False, "Ingles":True, "Chino":True, 
               "Frances":False, "Italiano":True}, 
    "Carlos" : {"Español":True, "Ingles":False, "Chino":False, 
                "Frances":True, "Italiano":True},
    "Ana" : {"Español":True, "Ingles":True, "Chino":True, 
             "Frances":False, "Italiano":True},
    "Maria" : {"Español":False, "Ingles":True, "Chino":False, 
               "Frances":False, "Italiano":True}
}

idioma = input("Ingrese un idioma: ")

for nombre, dicParticular in postulantes.items():
    if idioma in dicParticular and dicParticular[idioma] == True:
        print(nombre, 'habla', idioma)

"""###$\normal$  Une y triunfarás (continuación de Diccionario²)
Se recibieron distintos postulantes para un empleo de traductor. Crear un **diccionario** en el cuál la *key* de cada elemento sea el nombre de un candidato y el *contenido* sea un **set** con los idiomas que aprendió.
Inventar sets para 5 candidatos.

Ejemplo del **set** de idiomas:

```python
{"Español", "Inglés", "Portugués", "Italiano"}
```

- Mostrar en pantalla los idiomas que todos los candidatos aprendieron.
- Mostrar en pantalla todos los candidatos que aprendieron por lo menos Español e Inglés.

"""

postulantes = {
    "Juan" : {"Español", "Ingles", "Italiano"} , 
    "Pablo" : {"Ingles", "Chino", "Italiano"}, 
    "Carlos" : {"Español", "Frances", "Italiano"},
    "Ana" : {"Español", "Ingles", "Chino", "Italiano"},
    "Maria" : {"Ingles", "Italiano"}
}

# Creamos un set con todos los idiomas
todos = {"Español", "Ingles", "Chino", "Frances", "Italiano"}

for p in postulantes:
  todos &= postulantes[p] # Es lo mismo que: todos = todos & postulantes[p]

print("Todos los candidatos aprendieron este(os) idioma(s):")
for i in todos:
  print(i)

# Creamos un set vacio
esp_ing = set() 
for p in postulantes:
  if "Español" in postulantes[p] and "Ingles" in postulantes[p]:  
    # Qué postulantes que saben ingles y español
    esp_ing.add(p)

print("Los candidatos que aprendieron al menos Español e Inglés:")
for i in esp_ing:
  print(i)

"""### $\medio$ Análisis de idiomas

Importar el archivo **noticia.txt**
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/noticia.txt"

"""Calcular la [frecuencia de aparición de letras](https://es.wikipedia.org/wiki/Frecuencia_de_aparici%C3%B3n_de_letras). Compararla con la frecuencia de letras característica del idioma Español (en el articulo de wikipedia pueden encontrarla). ¿Existe alguna relación?

**Tips:**
- Pasar todas las letras a mayúsculas o todas a  minúsculas.
- Reemplazar las vocales con tilde por la misma vocal sin tilde antes de realizar el conteo.
- Descartar los números y caracteres no deseados. El método `.isalpha()` les puede ser de utilidad para este propósito.
"""

def segundo_valor(x):
  return x[1]

file = open("noticia.txt") # cargamos el archivo a la memoria
contenido = file.readlines() # calculamos todas las lineas

tildes = {'á':'a', 'é':'e', 'í':'i', 'ó':'o', 'ú':'u'}

total = 0
ocurrencias = {}
for renglon in contenido:
  renglon_lower = renglon.lower() # pasamos a minúscula el archivo.
  for letra in renglon_lower:
    # Si la letra tiene tilde, la remplazo por su versión sin tilde.
    if letra in tildes:     
      letra = tildes[letra]
    
    if letra.isalpha():     
      # Si la letra es alfanumerica, la agrego a la lista de ocurrencias.
      # Info get(): https://www.w3schools.com/python/ref_dictionary_get.asp
      ocurrencias[letra] = ocurrencias.get(letra, 0) + 1  
      total += 1

items = ocurrencias.items()

# Info Sorted: https://www.programiz.com/python-programming/methods/built-in/sorted
# Ordenamos las ocurrencias de mayor a menor.
lista = sorted(items, key = segundo_valor, reverse = True) 

for k,v in lista:
  print("{} aparece {} veces: {:0.3f} %".format(k, v, v/total * 100))

"""### $\dificil$ Menta y Dulce de leche

**Introducción:**

*Una de las muchas ventajas de los sets y los diccionarios es que permiten averiguar si contienen cierto elemento con gran velocidad, sin importar la cantidad de elementos que almacenan (esto se debe a que internamente utilizan una [función hash](https://es.wikipedia.org/wiki/Funci%C3%B3n_hash)). Acceder al valor asociado a cierta clave en un diccionario también es una operación muy veloz.*

*En comparación, verificar si un elemento se encuentra dentro de una lista es lento, ya que el tiempo necesario es proporcional a la cantidad de elementos en la lista y para listas muy grandes con miles, millones o billones de elementos (como puede suceder en una base de datos) esto puede ser un problema importante. Sin embargo, una vez que se conoce el índice del elemento, acceder al elemento es una operación tan rápida como en un diccionario.*

**Problema:**

Volviendo de hacer las compras en el supermercado, pasás cerca de una heladería y decidís comprar helado para tus hermanos, los cuales son amantes de la menta granizada y del dulce de leche con nuez. El negocio ofrece helado en todo tipo de formato, desde mini-cucuruchos hasta potes de 1 kilo, y cada formato cuesta cierta cantidad de dinero. Decidís gastar exactamente todo el dinero que te queda luego de haber ido al supermercado, de forma tal que no sobre ni falte.

Programar una función que recibe una lista con los precios de los distintos formatos en que se vende el helado, y además reciba la cantidad de dinero disponible para gastar. La función debe encontrar la manera de comprar cierto formato de helado sabor menta, y cierto formato sabor dulce de leche, de manera de gastar la totalidad del dinero disponible. En consecuencia, la cantidad de formatos seleccionados debe ser exactamente 2. Está permitido seleccionar el mismo formato para ambos sabores de helado. La función debe devolver con *return* una lista de 2 elementos, los cuales serán los precios de los formatos de helado seleccionados. En caso de no existir una combinación que satisface los requisitos se debe devolver ``[-1, -1]``.

**Tips:**
 - Al usar un set o un diccionario como estructura de datos pueden mejorar la velocidad con la que el programa analiza si cierto elemento se encuentra dentro de los datos. La operación ``mi_set = set( mi_lista )`` puede serles de utilidad para este propósito.

**Ejemplos:**

`buscar_precios( [1, 2, 3, 4, 5] , 8)` → `[3, 5]`

`buscar_precios( [7, 4, 2, 6, 7, 7] , 4)` → `[2, 2]`

`buscar_precios( [4, 3, 7, 5] , 5)` → `[-1, -1]`

\

$\dificil$ *Challenge*: Modificar la función para que el resultado sea un sólo número: La cantidad de maneras diferentes de conseguir el objetivo (si dos formatos tienen el mismo precio, igualmente califican como formatos diferentes).
"""

def buscar_precios(lista_precios, dinero):
  # Convertir la lista en un set
  set_precios = set(lista_precios)

  # Iterar por todos los precios en el set
  # Analizar si el dinero restante se encuentra en el set
  for p in set_precios:
    restante = dinero - p
    if restante in set_precios:
      return [p, restante]

  # En caso de no lograr una combinación, devolver [-1, -1]
  return [-1, -1]

print(buscar_precios( [1, 2, 3, 4, 5] , 8))
print(buscar_precios( [7, 4, 2, 6, 7, 7] , 4))
print(buscar_precios( [4, 3, 7, 5] , 5))

"""### $\dificil$ Dr. Chaos, el malevolo semiótico

"Chaos es caos en inglés" te diría Dr. Chaos, charlando con una taza de té Chai en la mano. En verdad no es tán malo como su nombre lo hace aparentar... si es que tenés un buen manejo de los idiomas.

Dr. Chaos esta armando un diccionario. Este diccionario tiene la particularidad de no tener definiciones; el diccionario de Dr. Chaos define *una palabra como otra*. Dr. Chaos quiere comenzar a traducir la literatura de todo el mundo usando el diccionario y ha venido a ti, el *Number One* programador de Python. 

**Objetivo:** Cambiar las palabras de una oración usando el diccionario de Dr. Chaos e imprimir la nueva oración en el lenguaje unificado.

**Ejemplos:**

 - Input 1:
 ```python 
diccionario = {"hola":"你好","como":"how","estás":"estáis"}
oracion = "hola, como estás?"
```
  Output 1:
```python 
"你好, how estáis?"
```

 - Input 2:
 ```python 
diccionario = {"ve":"regards","bien":"bom","se":"it"}
oracion = "se ve bien!"
```

 Output 2:
```python 
"it regards bom!"
```


**Tips:** 

* Los símbolos de interrogación, exclamación, los puntos y comas no forman parte de las palabras y no se deben modificar.
 
* Suponer que las letras son todas minúsculas.

"""

# Solución 1

espanolToChaos = {"ve":"regards", "bien":"bom", "se":"it"}
oracion = "se ve bien!"
whitespace = [" ", ".", ",", "!", "?"]

resultado = ""
palabra = ""
for i in range(0, len(oracion)):
    letra = oracion[i]
    if letra in whitespace: # reviso si la letra es una espacio en blanco
        if palabra != "":
            # traducir la palabra que tengo hasta ahora y agregarla
            resultado = resultado+espanolToChaos[palabra] 
    
        resultado = resultado+letra # agrego el espacio a la palabra nueva
        palabra = ""
    else:
        palabra = palabra + letra
        
print(resultado)

"""###$\imposible$ Quiero Retruco
El [Truco](https://es.wikipedia.org/wiki/Truco_argentino) es un juego de cartas muy popular en Argentina. Se suele jugar con naipes españoles de 40 cartas, las cuales tienen 4 palos (basto, oro, espada y copa) y 10 números (1, 2, 3, 4, 5, 6, 7, 10, 11 y 12).
Si bien en esta ocasión no vamos a programar un juego de truco, sí vamos a resolver uno de los problemas más usuales que surgen cuando jugamos, el cual es definir qué carta gana y qué carta pierde cuando hay un duelo entre dos cartas. 

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/truco_jerarquia.png" height=300 alt ="Esquema de hierarquia de cartas para el juego truco argentino" title="Un palo le gana a 7 espadas y ambos pierden ante una espada envainada? What?">

En la imagen podemos observar el orden de importancia de las cartas de izquierda a derecha. El 1 de espada es la más importante (y por lo tanto **siempre** gana) mientras que los 4s son las cartas de menor importancia (casi siempre pierden). Las cartas en la misma columna empatan si se enfrentan.

- Programar una función con dos inputs tipo string **carta A** y **carta B** que retorne la carta ganadora (tipo string), o "empate" en caso de que lo haya. Ejemplos de como debería funcionar

 ```
   dueloDeCartas("1 de espada", "1 de basto")
   >>> 1 de espada
   dueloDeCartas("7 de oro", "5 de oro")
   >>> 7 de oro
   dueloDeCartas("11 de copa", "11 de espada")
   >>> empate
```

 **Pista** (el texto a continuación es de color blanco, seleccionar para poder verlo): <font color="white"> Usar un diccionario donde la **clave** sea el nombre de la carta, y su **contenido** su importancia (un tipo **int**). Aprovechen la instrucción *for* para evitar tener que cargar todas las cartas una por una.
</font>

- A veces se suele jugar al truco con más de dos jugadores. Podría ocurrir duelos en los que participan $n$ cartas. Programar una función cuyo input sea una lista de strings con todas las cartas y retorne la ganadora. (En caso de empate que retorne alguna de las ganadoras, o una lista con las ganadoras).
Ejemplos de como podría funcionar:
```
   dueloDeCartas(["7 de basto","7 de espada","12 de espada", "4 de espada"])
   >>> "7 de espada"
   dueloDeCartas(["4 de espada","7 de basto","7 de copa", "5 de copa"]) #también podría haber dado 7 de basto 
   >>> "7 de copa"
```
"""

# Solución 1: diccionario

""" 
Antes de hacer la funcion dueloDeCartas, creamos el diccionario que leerá 
para saber que carta gana 
"""

valorCarta = dict() 

# casos especiales: esto no lo puedo hacer con un for
valorCarta["1 de espada"] = 14    
valorCarta["1 de basto"] = 13     
valorCarta["7 de espada"] = 12
valorCarta["7 de oro"] = 11

# el resto de los valores son de 10 para abajo
valor = 10
for x in [3, 2, 1, 12, 11, 10, 7, 6, 5, 4]: 
    # itero por los numeros de las cartas, de la mas a la menos poderosa
    if x == 1: # con este if elijo que palos de este numero guardo
        palos = ["oro","copa"] 
    elif x == 7:
        palos = ["basto", "copa"]
    else: 
        palos = ["oro", "copa", "basto", "espada"]

    # para todos los palos que elegí, guardo la carta con el mismo valor
    for palo in palos:
        valorCarta[str(x) + " de " + palo] = valor
        
    valor -= 1 # la carta que viene es menos poderosa

def dueloDeCartas(cartaA, cartaB):
    # usamos el diccionario que creamos para saber el valor de las cartas
    # que nos pasan
    if valorCarta[cartaA] > valorCarta[cartaB]:
        return cartaA
    elif valorCarta[cartaA] < valorCarta[cartaB]:
        return cartaB
    else:
        return "empate"
    
    
# verificamos que la funcion ande correctamente
print(dueloDeCartas("7 de basto","1 de basto"))
print(dueloDeCartas("1 de copa", "1 de oro"))
print(dueloDeCartas("7 de copa","3 de copa"))

"""#Anexos
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

## Anexo A: JSON

*JSON* es un formato de representación de información estructurada que es de gran utilidad. Su sintaxis es simple y fácil de leer a simple vista, además de que tiene una gran similitud con la sintaxis propia de Python. En la [página web de *JSON*](https://www.json.org/json-es.html) hay explicaciones bastante claras acerca de los detalles de su sintaxis.

En *JSON* los objetos se rodean con llaves `{objeto}`, las listas con corchetes `[lista]` y los strings con comillas dobles `"string"`. Por el momento se puede pensar que un objeto es igual a un diccionario de Python, pudiendo almacenar datos con claves, por ejemplo:

```json
{  
  "columna_1": [1, 8, 4, 6, 2, 8, 5],
  "columna_2": [99, 56, 223, 301, 56, 2],
  "columna_2": [0, -1, -66, -210, -333, 334]
}
```

El texto de arriba es código de Python _válido_ y un objeto json! Si quisieramos cargarlo a nuestro código Python bastaría con copiarlo y pegarlo a nuestro código. Pero no siempre vamos a estar nosotros para copiar y pegar el texto json. 

En el caso presentado a continuación se tiene un string de código json y precisamos [leerlo y procesarlo](https://www.w3schools.com/python/python_json.asp). Para eso usamos el modulo `json` de Python. A continuación se muestra un ejemplo:
"""

import json
s = '{ "a" : [1, 2, 3], "b" : [4, 6, 8], "c":[99, 98, 97] }'
d= json.loads(s)
print(d["a"])
print(len(d["b"]))
print(sum(d["c"]))

"""Verán que se imprimen la lista `"a"`, la longitud de la lista `"b"` y la suma de los elementos de la lista `"c"`.

Vamos a utilizar en el próximo desafío **opcional** la librería `json` para leer el texto que nos llega por `input()`, lo cual podría ocurrir si estamos comunicándonos con un servidor.

### **Opcional**: Mini-desafío json
Estás encargado de un servidor con millones de usuarios. 

Se pide escribir un programa que reciba el email y contraseña del usuario y se fije si existe el usuario y si coincide la contraseña.

Se tienen datos encolumnados en formato json que nos llegan en el siguiente formato:
```json
{
	"usuarios" : ["mica@mail.co", "jerry@gma.com","alber@soup.co"],
	"contra" : ["abc123", "caballitos", "yoloswag"]
}
```
La entrada del programa son tres líneas, el programa entonces va tener tres `input()`. La primer línea contiene el `json`, la segunda el `email` a verificar, y la tercera la `contraseña`. Por ende, las primeras líneas de su programa podrían ser:
```python
import json
usuarios = json.loads(input())
email = input()
password = input()
```

La salida del programa será `OK` si el usuario **se encuentra en la base de datos** ***y*** **si coincide la contraseña**, imprimimos `DNE` (does not exist) si el usuario no existe y `NO` en cualquier otro caso.

#### Caso ejemplo
**Entrada**:
```json
{"usuarios": ["mica@mail.co","jerry@gma.com","alber@soup.co"],"contra": ["abc123","caballitos","yoloswag"]}
mica@mail.co
caballitos
```
El usuario existe y la contraseña también... pero no le corresponde la contraseña `caballitos` al usuario `mica@mail.co` (la contraseña de `mica@mail.co` sería `abc123`) por ende imprimimos:

**Salida**
```
NO
```

_Considere que no hay usuarios repetidos_.
"""

import json


usuarios = json.loads(input())
email = input("Mail: ")
password = input("Contraseña: ")

if email in usuarios["usuarios"]:
  index = usuarios["usuarios"].index(email)
  if password == usuarios["contra"][index]:
    print("OK")
  else:
    print("NO")
else:
  print("DNE")

"""## Anexo B: API's

En este curso, uno de los objetivos es poder automatizar tareas comunes. Ya empezamos a ver cómo podemos interactuar con archivos de datos desde nuestro programa en Python, pero esto puede no ser suficiente. Es usual tener que interactuar con una aplicación desde nuestro programa, por ejemplo, nuestro programa podría querer acceder a una página web, o al servidor de nuestra empresa. 

Para lograr la interacción entre una aplicación y nuestro programa se utilizan API's (Application Programming Interface), las cuales permiten estandarizar el formato de la información que se intercambia. Para lograr esta comunicación una de las herramientas más comunes es el uso de archivos *JSON* ya que de manera simple y concisa pueden representar estructuras de datos relativamente complejas. 

No todas las aplicaciones tendrán API's ya que depende de su creador programar esta interfaz o no, además, no todas las API's proveen el acceso a todos los datos deseados por lo cual es posible que haya que recurrir a otros métodos menos elegantes para obtener la información deseada.

[Este video](https://youtu.be/BxV14h0kFs0) hecho por Tom Scott puede ayudar para comprender un poco más acerca de qué se tratan las API's.

Para mostrar un ejemplo práctico del uso de API's, utilizamos uno de los códigos de ejemplo en la documentación de la API de YouTube que pueden ver en [este link](https://developers.google.com/youtube/reporting/v1/code_samples/python?hl=es#retrieve_daily_channel_statistics). Las aplicaciones de Google (Maps, Youtube, etc.) suelen tener API's relativamente buenas y completas. En este caso el ejemplo obtiene ciertas estadísticas del [Canal de YouTube de IEEE-ITBA](https://www.youtube.com/channel/UCpWHvOSiPtDIwIw8Tb_9g6A/featured) entre los días 1 y 13 del mes de octubre 2020. Los resultados **reales** de este programa se muestran a continuación tal cual como fueron enviados por la API de YouTube y recibidos por nuestro programa en Python:

```json
{
    "columnHeaders": [
        {
            "columnType": "DIMENSION",
            "dataType": "STRING",
            "name": "day"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "estimatedMinutesWatched"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "views"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "likes"
        },
        {
            "columnType": "METRIC",
            "dataType": "INTEGER",
            "name": "subscribersGained"
        }
    ],
    "kind": "youtubeAnalytics#resultTable",
    "rows": [
        [
            "2020-10-01",
            26,
            19,
            0,
            0
        ],
        [
            "2020-10-02",
            2,
            14,
            0,
            0
        ],
        [
            "2020-10-03",
            120,
            78,
            0,
            1
        ],
        [
            "2020-10-04",
            3280,
            1203,
            75,
            88
        ],
        [
            "2020-10-05",
            2064,
            747,
            22,
            44
        ],
        [
            "2020-10-06",
            2290,
            824,
            28,
            26
        ],
        [
            "2020-10-07",
            2817,
            950,
            13,
            20
        ],
        [
            "2020-10-08",
            4594,
            1491,
            9,
            14
        ],
        [
            "2020-10-09",
            4238,
            1254,
            17,
            19
        ],
        [
            "2020-10-10",
            31783,
            3231,
            126,
            102
        ],
        [
            "2020-10-11",
            6233,
            1529,
            18,
            22
        ],
        [
            "2020-10-12",
            4786,
            1138,
            9,
            7
        ],
        [
            "2020-10-13",
            3977,
            761,
            17,
            13
        ]
    ]
}
```

Como se puede observar, el formato de los datos está definido por la API de YouTube, y consiste en una lista ```columnHeaders``` con los datos de cada columna, como por ejemplo el nombre de la columna, y luego una lista ```rows``` con los datos de cada fila en el mismo orden en que se indicaron las columnas.

Usando la API de YouTube, por ejemplo, se puede automatizar el análisis de las estadísticas de videos e incluso realizar cambios acordemente para mejorar su rendimiento. Por ejemplo: cambiar el título, la imagen de portada, los subtítulos, etc. Usando la API de Google Maps se puede llegar a incorporar funcionalidad de mapas o de geolocalización a nuestra aplicación.

En conclusión, las API's nos permiten interactuar desde nuestro programa con otras aplicaciones de forma simple y estandarizada para aprovechar todas las herramientas que nos ofrecen, y podemos automatizar este proceso utilizando Python.

## Anexo C: Algunos Tips extra para Python

A continuación les dejamos un fragmento de una transmisión en vivo de años anteriores, en la cual se explican diversos trucos y funciones que tiene Python, algunos de los cuales no fueron explicados en la clase pero que pueden serles de utilidad en ciertos casos.

Temas:
* min( ) y max( )
* enumerate
* valor vs. referencia
* tipos mutables e inmutables
* Copiado superficial y en profundidad
"""

# Link a Youtube: https://www.youtube.com/watch?v=YzLOST80M6M

from IPython.display import YouTubeVideo
YouTubeVideo('YzLOST80M6M', start=562, end=2580, width=800, height=450)